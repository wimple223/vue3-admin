var __getOwnPropNames = Object.getOwnPropertyNames;
var __commonJS = (cb, mod) => function __require() {
  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};

// node_modules/ignore/index.js
var require_index = __commonJS({
  "node_modules/ignore/index.js"(exports, module) {
    function makeArray(subject) {
      return Array.isArray(subject) ? subject : [subject];
    }
    var EMPTY = "";
    var SPACE = " ";
    var ESCAPE = "\\";
    var REGEX_TEST_BLANK_LINE = /^\s+$/;
    var REGEX_INVALID_TRAILING_BACKSLASH = /(?:[^\\]|^)\\$/;
    var REGEX_REPLACE_LEADING_EXCAPED_EXCLAMATION = /^\\!/;
    var REGEX_REPLACE_LEADING_EXCAPED_HASH = /^\\#/;
    var REGEX_SPLITALL_CRLF = /\r?\n/g;
    var REGEX_TEST_INVALID_PATH = /^\.*\/|^\.+$/;
    var SLASH = "/";
    var TMP_KEY_IGNORE = "node-ignore";
    if (typeof Symbol !== "undefined") {
      TMP_KEY_IGNORE = Symbol.for("node-ignore");
    }
    var KEY_IGNORE = TMP_KEY_IGNORE;
    var define = (object, key, value) => Object.defineProperty(object, key, { value });
    var REGEX_REGEXP_RANGE = /([0-z])-([0-z])/g;
    var RETURN_FALSE = () => false;
    var sanitizeRange = (range) => range.replace(
      REGEX_REGEXP_RANGE,
      (match, from, to) => from.charCodeAt(0) <= to.charCodeAt(0) ? match : EMPTY
    );
    var cleanRangeBackSlash = (slashes) => {
      const { length } = slashes;
      return slashes.slice(0, length - length % 2);
    };
    var REPLACERS = [
      [
        // remove BOM
        // TODO:
        // Other similar zero-width characters?
        /^\uFEFF/,
        () => EMPTY
      ],
      // > Trailing spaces are ignored unless they are quoted with backslash ("\")
      [
        // (a\ ) -> (a )
        // (a  ) -> (a)
        // (a ) -> (a)
        // (a \ ) -> (a  )
        /((?:\\\\)*?)(\\?\s+)$/,
        (_, m1, m2) => m1 + (m2.indexOf("\\") === 0 ? SPACE : EMPTY)
      ],
      // replace (\ ) with ' '
      // (\ ) -> ' '
      // (\\ ) -> '\\ '
      // (\\\ ) -> '\\ '
      [
        /(\\+?)\s/g,
        (_, m1) => {
          const { length } = m1;
          return m1.slice(0, length - length % 2) + SPACE;
        }
      ],
      // Escape metacharacters
      // which is written down by users but means special for regular expressions.
      // > There are 12 characters with special meanings:
      // > - the backslash \,
      // > - the caret ^,
      // > - the dollar sign $,
      // > - the period or dot .,
      // > - the vertical bar or pipe symbol |,
      // > - the question mark ?,
      // > - the asterisk or star *,
      // > - the plus sign +,
      // > - the opening parenthesis (,
      // > - the closing parenthesis ),
      // > - and the opening square bracket [,
      // > - the opening curly brace {,
      // > These special characters are often called "metacharacters".
      [
        /[\\$.|*+(){^]/g,
        (match) => `\\${match}`
      ],
      [
        // > a question mark (?) matches a single character
        /(?!\\)\?/g,
        () => "[^/]"
      ],
      // leading slash
      [
        // > A leading slash matches the beginning of the pathname.
        // > For example, "/*.c" matches "cat-file.c" but not "mozilla-sha1/sha1.c".
        // A leading slash matches the beginning of the pathname
        /^\//,
        () => "^"
      ],
      // replace special metacharacter slash after the leading slash
      [
        /\//g,
        () => "\\/"
      ],
      [
        // > A leading "**" followed by a slash means match in all directories.
        // > For example, "**/foo" matches file or directory "foo" anywhere,
        // > the same as pattern "foo".
        // > "**/foo/bar" matches file or directory "bar" anywhere that is directly
        // >   under directory "foo".
        // Notice that the '*'s have been replaced as '\\*'
        /^\^*\\\*\\\*\\\//,
        // '**/foo' <-> 'foo'
        () => "^(?:.*\\/)?"
      ],
      // starting
      [
        // there will be no leading '/'
        //   (which has been replaced by section "leading slash")
        // If starts with '**', adding a '^' to the regular expression also works
        /^(?=[^^])/,
        function startingReplacer() {
          return !/\/(?!$)/.test(this) ? "(?:^|\\/)" : "^";
        }
      ],
      // two globstars
      [
        // Use lookahead assertions so that we could match more than one `'/**'`
        /\\\/\\\*\\\*(?=\\\/|$)/g,
        // Zero, one or several directories
        // should not use '*', or it will be replaced by the next replacer
        // Check if it is not the last `'/**'`
        (_, index, str) => index + 6 < str.length ? "(?:\\/[^\\/]+)*" : "\\/.+"
      ],
      // normal intermediate wildcards
      [
        // Never replace escaped '*'
        // ignore rule '\*' will match the path '*'
        // 'abc.*/' -> go
        // 'abc.*'  -> skip this rule,
        //    coz trailing single wildcard will be handed by [trailing wildcard]
        /(^|[^\\]+)(\\\*)+(?=.+)/g,
        // '*.js' matches '.js'
        // '*.js' doesn't match 'abc'
        (_, p1, p2) => {
          const unescaped = p2.replace(/\\\*/g, "[^\\/]*");
          return p1 + unescaped;
        }
      ],
      [
        // unescape, revert step 3 except for back slash
        // For example, if a user escape a '\\*',
        // after step 3, the result will be '\\\\\\*'
        /\\\\\\(?=[$.|*+(){^])/g,
        () => ESCAPE
      ],
      [
        // '\\\\' -> '\\'
        /\\\\/g,
        () => ESCAPE
      ],
      [
        // > The range notation, e.g. [a-zA-Z],
        // > can be used to match one of the characters in a range.
        // `\` is escaped by step 3
        /(\\)?\[([^\]/]*?)(\\*)($|\])/g,
        (match, leadEscape, range, endEscape, close) => leadEscape === ESCAPE ? `\\[${range}${cleanRangeBackSlash(endEscape)}${close}` : close === "]" ? endEscape.length % 2 === 0 ? `[${sanitizeRange(range)}${endEscape}]` : "[]" : "[]"
      ],
      // ending
      [
        // 'js' will not match 'js.'
        // 'ab' will not match 'abc'
        /(?:[^*])$/,
        // WTF!
        // https://git-scm.com/docs/gitignore
        // changes in [2.22.1](https://git-scm.com/docs/gitignore/2.22.1)
        // which re-fixes #24, #38
        // > If there is a separator at the end of the pattern then the pattern
        // > will only match directories, otherwise the pattern can match both
        // > files and directories.
        // 'js*' will not match 'a.js'
        // 'js/' will not match 'a.js'
        // 'js' will match 'a.js' and 'a.js/'
        (match) => /\/$/.test(match) ? `${match}$` : `${match}(?=$|\\/$)`
      ],
      // trailing wildcard
      [
        /(\^|\\\/)?\\\*$/,
        (_, p1) => {
          const prefix = p1 ? `${p1}[^/]+` : "[^/]*";
          return `${prefix}(?=$|\\/$)`;
        }
      ]
    ];
    var regexCache = /* @__PURE__ */ Object.create(null);
    var makeRegex = (pattern, ignoreCase) => {
      let source = regexCache[pattern];
      if (!source) {
        source = REPLACERS.reduce(
          (prev, [matcher, replacer]) => prev.replace(matcher, replacer.bind(pattern)),
          pattern
        );
        regexCache[pattern] = source;
      }
      return ignoreCase ? new RegExp(source, "i") : new RegExp(source);
    };
    var isString = (subject) => typeof subject === "string";
    var checkPattern = (pattern) => pattern && isString(pattern) && !REGEX_TEST_BLANK_LINE.test(pattern) && !REGEX_INVALID_TRAILING_BACKSLASH.test(pattern) && pattern.indexOf("#") !== 0;
    var splitPattern = (pattern) => pattern.split(REGEX_SPLITALL_CRLF);
    var IgnoreRule = class {
      constructor(origin, pattern, negative, regex) {
        this.origin = origin;
        this.pattern = pattern;
        this.negative = negative;
        this.regex = regex;
      }
    };
    var createRule = (pattern, ignoreCase) => {
      const origin = pattern;
      let negative = false;
      if (pattern.indexOf("!") === 0) {
        negative = true;
        pattern = pattern.substr(1);
      }
      pattern = pattern.replace(REGEX_REPLACE_LEADING_EXCAPED_EXCLAMATION, "!").replace(REGEX_REPLACE_LEADING_EXCAPED_HASH, "#");
      const regex = makeRegex(pattern, ignoreCase);
      return new IgnoreRule(
        origin,
        pattern,
        negative,
        regex
      );
    };
    var throwError = (message, Ctor) => {
      throw new Ctor(message);
    };
    var checkPath = (path, originalPath, doThrow) => {
      if (!isString(path)) {
        return doThrow(
          `path must be a string, but got \`${originalPath}\``,
          TypeError
        );
      }
      if (!path) {
        return doThrow(`path must not be empty`, TypeError);
      }
      if (checkPath.isNotRelative(path)) {
        const r = "`path.relative()`d";
        return doThrow(
          `path should be a ${r} string, but got "${originalPath}"`,
          RangeError
        );
      }
      return true;
    };
    var isNotRelative = (path) => REGEX_TEST_INVALID_PATH.test(path);
    checkPath.isNotRelative = isNotRelative;
    checkPath.convert = (p) => p;
    var Ignore = class {
      constructor({
        ignorecase = true,
        ignoreCase = ignorecase,
        allowRelativePaths = false
      } = {}) {
        define(this, KEY_IGNORE, true);
        this._rules = [];
        this._ignoreCase = ignoreCase;
        this._allowRelativePaths = allowRelativePaths;
        this._initCache();
      }
      _initCache() {
        this._ignoreCache = /* @__PURE__ */ Object.create(null);
        this._testCache = /* @__PURE__ */ Object.create(null);
      }
      _addPattern(pattern) {
        if (pattern && pattern[KEY_IGNORE]) {
          this._rules = this._rules.concat(pattern._rules);
          this._added = true;
          return;
        }
        if (checkPattern(pattern)) {
          const rule = createRule(pattern, this._ignoreCase);
          this._added = true;
          this._rules.push(rule);
        }
      }
      // @param {Array<string> | string | Ignore} pattern
      add(pattern) {
        this._added = false;
        makeArray(
          isString(pattern) ? splitPattern(pattern) : pattern
        ).forEach(this._addPattern, this);
        if (this._added) {
          this._initCache();
        }
        return this;
      }
      // legacy
      addPattern(pattern) {
        return this.add(pattern);
      }
      //          |           ignored : unignored
      // negative |   0:0   |   0:1   |   1:0   |   1:1
      // -------- | ------- | ------- | ------- | --------
      //     0    |  TEST   |  TEST   |  SKIP   |    X
      //     1    |  TESTIF |  SKIP   |  TEST   |    X
      // - SKIP: always skip
      // - TEST: always test
      // - TESTIF: only test if checkUnignored
      // - X: that never happen
      // @param {boolean} whether should check if the path is unignored,
      //   setting `checkUnignored` to `false` could reduce additional
      //   path matching.
      // @returns {TestResult} true if a file is ignored
      _testOne(path, checkUnignored) {
        let ignored = false;
        let unignored = false;
        this._rules.forEach((rule) => {
          const { negative } = rule;
          if (unignored === negative && ignored !== unignored || negative && !ignored && !unignored && !checkUnignored) {
            return;
          }
          const matched = rule.regex.test(path);
          if (matched) {
            ignored = !negative;
            unignored = negative;
          }
        });
        return {
          ignored,
          unignored
        };
      }
      // @returns {TestResult}
      _test(originalPath, cache, checkUnignored, slices) {
        const path = originalPath && checkPath.convert(originalPath);
        checkPath(
          path,
          originalPath,
          this._allowRelativePaths ? RETURN_FALSE : throwError
        );
        return this._t(path, cache, checkUnignored, slices);
      }
      _t(path, cache, checkUnignored, slices) {
        if (path in cache) {
          return cache[path];
        }
        if (!slices) {
          slices = path.split(SLASH);
        }
        slices.pop();
        if (!slices.length) {
          return cache[path] = this._testOne(path, checkUnignored);
        }
        const parent = this._t(
          slices.join(SLASH) + SLASH,
          cache,
          checkUnignored,
          slices
        );
        return cache[path] = parent.ignored ? parent : this._testOne(path, checkUnignored);
      }
      ignores(path) {
        return this._test(path, this._ignoreCache, false).ignored;
      }
      createFilter() {
        return (path) => !this.ignores(path);
      }
      filter(paths) {
        return makeArray(paths).filter(this.createFilter());
      }
      // @returns {TestResult}
      test(path) {
        return this._test(path, this._testCache, true);
      }
    };
    var factory = (options) => new Ignore(options);
    var isPathValid = (path) => checkPath(path && checkPath.convert(path), path, RETURN_FALSE);
    factory.isPathValid = isPathValid;
    factory.default = factory;
    module.exports = factory;
    if (
      // Detect `process` so that it can run in browsers.
      typeof process !== "undefined" && (process.env && process.env.IGNORE_TEST_WIN32 || process.platform === "win32")
    ) {
      const makePosix = (str) => /^\\\\\?\\/.test(str) || /["<>|\u0000-\u001F]+/u.test(str) ? str : str.replace(/\\/g, "/");
      checkPath.convert = makePosix;
      const REGIX_IS_WINDOWS_PATH_ABSOLUTE = /^[a-z]:\//i;
      checkPath.isNotRelative = (path) => REGIX_IS_WINDOWS_PATH_ABSOLUTE.test(path) || isNotRelative(path);
    }
  }
});
export default require_index();
//# sourceMappingURL=data:application/json;base64,ewogICJ2ZXJzaW9uIjogMywKICAic291cmNlcyI6IFsibm9kZV9tb2R1bGVzL2lnbm9yZS9pbmRleC5qcyJdLAogICJzb3VyY2VzQ29udGVudCI6IFsiY29uc3QgX19pbmplY3RlZF9maWxlbmFtZV9fID0gXCJFOlxcXFxxZFxcXFx2dWUzLWFkbWluXFxcXG5vZGVfbW9kdWxlc1xcXFxpZ25vcmVcXFxcaW5kZXguanNcIjtjb25zdCBfX2luamVjdGVkX2Rpcm5hbWVfXyA9IFwiRTpcXFxccWRcXFxcdnVlMy1hZG1pblxcXFxub2RlX21vZHVsZXNcXFxcaWdub3JlXCI7Y29uc3QgX19pbmplY3RlZF9pbXBvcnRfbWV0YV91cmxfXyA9IFwiZmlsZTovLy9FOi9xZC92dWUzLWFkbWluL25vZGVfbW9kdWxlcy9pZ25vcmUvaW5kZXguanNcIjsvLyBBIHNpbXBsZSBpbXBsZW1lbnRhdGlvbiBvZiBtYWtlLWFycmF5XG5mdW5jdGlvbiBtYWtlQXJyYXkgKHN1YmplY3QpIHtcbiAgcmV0dXJuIEFycmF5LmlzQXJyYXkoc3ViamVjdClcbiAgICA/IHN1YmplY3RcbiAgICA6IFtzdWJqZWN0XVxufVxuXG5jb25zdCBFTVBUWSA9ICcnXG5jb25zdCBTUEFDRSA9ICcgJ1xuY29uc3QgRVNDQVBFID0gJ1xcXFwnXG5jb25zdCBSRUdFWF9URVNUX0JMQU5LX0xJTkUgPSAvXlxccyskL1xuY29uc3QgUkVHRVhfSU5WQUxJRF9UUkFJTElOR19CQUNLU0xBU0ggPSAvKD86W15cXFxcXXxeKVxcXFwkL1xuY29uc3QgUkVHRVhfUkVQTEFDRV9MRUFESU5HX0VYQ0FQRURfRVhDTEFNQVRJT04gPSAvXlxcXFwhL1xuY29uc3QgUkVHRVhfUkVQTEFDRV9MRUFESU5HX0VYQ0FQRURfSEFTSCA9IC9eXFxcXCMvXG5jb25zdCBSRUdFWF9TUExJVEFMTF9DUkxGID0gL1xccj9cXG4vZ1xuLy8gL2Zvbyxcbi8vIC4vZm9vLFxuLy8gLi4vZm9vLFxuLy8gLlxuLy8gLi5cbmNvbnN0IFJFR0VYX1RFU1RfSU5WQUxJRF9QQVRIID0gL15cXC4qXFwvfF5cXC4rJC9cblxuY29uc3QgU0xBU0ggPSAnLydcblxuLy8gRG8gbm90IHVzZSB0ZXJuYXJ5IGV4cHJlc3Npb24gaGVyZSwgc2luY2UgXCJpc3RhbmJ1bCBpZ25vcmUgbmV4dFwiIGlzIGJ1Z2d5XG5sZXQgVE1QX0tFWV9JR05PUkUgPSAnbm9kZS1pZ25vcmUnXG4vKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL1xuaWYgKHR5cGVvZiBTeW1ib2wgIT09ICd1bmRlZmluZWQnKSB7XG4gIFRNUF9LRVlfSUdOT1JFID0gU3ltYm9sLmZvcignbm9kZS1pZ25vcmUnKVxufVxuY29uc3QgS0VZX0lHTk9SRSA9IFRNUF9LRVlfSUdOT1JFXG5cbmNvbnN0IGRlZmluZSA9IChvYmplY3QsIGtleSwgdmFsdWUpID0+XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvYmplY3QsIGtleSwge3ZhbHVlfSlcblxuY29uc3QgUkVHRVhfUkVHRVhQX1JBTkdFID0gLyhbMC16XSktKFswLXpdKS9nXG5cbmNvbnN0IFJFVFVSTl9GQUxTRSA9ICgpID0+IGZhbHNlXG5cbi8vIFNhbml0aXplIHRoZSByYW5nZSBvZiBhIHJlZ3VsYXIgZXhwcmVzc2lvblxuLy8gVGhlIGNhc2VzIGFyZSBjb21wbGljYXRlZCwgc2VlIHRlc3QgY2FzZXMgZm9yIGRldGFpbHNcbmNvbnN0IHNhbml0aXplUmFuZ2UgPSByYW5nZSA9PiByYW5nZS5yZXBsYWNlKFxuICBSRUdFWF9SRUdFWFBfUkFOR0UsXG4gIChtYXRjaCwgZnJvbSwgdG8pID0+IGZyb20uY2hhckNvZGVBdCgwKSA8PSB0by5jaGFyQ29kZUF0KDApXG4gICAgPyBtYXRjaFxuICAgIC8vIEludmFsaWQgcmFuZ2UgKG91dCBvZiBvcmRlcikgd2hpY2ggaXMgb2sgZm9yIGdpdGlnbm9yZSBydWxlcyBidXRcbiAgICAvLyAgIGZhdGFsIGZvciBKYXZhU2NyaXB0IHJlZ3VsYXIgZXhwcmVzc2lvbiwgc28gZWxpbWluYXRlIGl0LlxuICAgIDogRU1QVFlcbilcblxuLy8gU2VlIGZpeHR1cmVzICM1OVxuY29uc3QgY2xlYW5SYW5nZUJhY2tTbGFzaCA9IHNsYXNoZXMgPT4ge1xuICBjb25zdCB7bGVuZ3RofSA9IHNsYXNoZXNcbiAgcmV0dXJuIHNsYXNoZXMuc2xpY2UoMCwgbGVuZ3RoIC0gbGVuZ3RoICUgMilcbn1cblxuLy8gPiBJZiB0aGUgcGF0dGVybiBlbmRzIHdpdGggYSBzbGFzaCxcbi8vID4gaXQgaXMgcmVtb3ZlZCBmb3IgdGhlIHB1cnBvc2Ugb2YgdGhlIGZvbGxvd2luZyBkZXNjcmlwdGlvbixcbi8vID4gYnV0IGl0IHdvdWxkIG9ubHkgZmluZCBhIG1hdGNoIHdpdGggYSBkaXJlY3RvcnkuXG4vLyA+IEluIG90aGVyIHdvcmRzLCBmb28vIHdpbGwgbWF0Y2ggYSBkaXJlY3RvcnkgZm9vIGFuZCBwYXRocyB1bmRlcm5lYXRoIGl0LFxuLy8gPiBidXQgd2lsbCBub3QgbWF0Y2ggYSByZWd1bGFyIGZpbGUgb3IgYSBzeW1ib2xpYyBsaW5rIGZvb1xuLy8gPiAgKHRoaXMgaXMgY29uc2lzdGVudCB3aXRoIHRoZSB3YXkgaG93IHBhdGhzcGVjIHdvcmtzIGluIGdlbmVyYWwgaW4gR2l0KS5cbi8vICdgZm9vL2AnIHdpbGwgbm90IG1hdGNoIHJlZ3VsYXIgZmlsZSAnYGZvb2AnIG9yIHN5bWJvbGljIGxpbmsgJ2Bmb29gJ1xuLy8gLT4gaWdub3JlLXJ1bGVzIHdpbGwgbm90IGRlYWwgd2l0aCBpdCwgYmVjYXVzZSBpdCBjb3N0cyBleHRyYSBgZnMuc3RhdGAgY2FsbFxuLy8gICAgICB5b3UgY291bGQgdXNlIG9wdGlvbiBgbWFyazogdHJ1ZWAgd2l0aCBgZ2xvYmBcblxuLy8gJ2Bmb28vYCcgc2hvdWxkIG5vdCBjb250aW51ZSB3aXRoIHRoZSAnYC4uYCdcbmNvbnN0IFJFUExBQ0VSUyA9IFtcblxuICBbXG4gICAgLy8gcmVtb3ZlIEJPTVxuICAgIC8vIFRPRE86XG4gICAgLy8gT3RoZXIgc2ltaWxhciB6ZXJvLXdpZHRoIGNoYXJhY3RlcnM/XG4gICAgL15cXHVGRUZGLyxcbiAgICAoKSA9PiBFTVBUWVxuICBdLFxuXG4gIC8vID4gVHJhaWxpbmcgc3BhY2VzIGFyZSBpZ25vcmVkIHVubGVzcyB0aGV5IGFyZSBxdW90ZWQgd2l0aCBiYWNrc2xhc2ggKFwiXFxcIilcbiAgW1xuICAgIC8vIChhXFwgKSAtPiAoYSApXG4gICAgLy8gKGEgICkgLT4gKGEpXG4gICAgLy8gKGEgKSAtPiAoYSlcbiAgICAvLyAoYSBcXCApIC0+IChhICApXG4gICAgLygoPzpcXFxcXFxcXCkqPykoXFxcXD9cXHMrKSQvLFxuICAgIChfLCBtMSwgbTIpID0+IG0xICsgKFxuICAgICAgbTIuaW5kZXhPZignXFxcXCcpID09PSAwXG4gICAgICAgID8gU1BBQ0VcbiAgICAgICAgOiBFTVBUWVxuICAgIClcbiAgXSxcblxuICAvLyByZXBsYWNlIChcXCApIHdpdGggJyAnXG4gIC8vIChcXCApIC0+ICcgJ1xuICAvLyAoXFxcXCApIC0+ICdcXFxcICdcbiAgLy8gKFxcXFxcXCApIC0+ICdcXFxcICdcbiAgW1xuICAgIC8oXFxcXCs/KVxccy9nLFxuICAgIChfLCBtMSkgPT4ge1xuICAgICAgY29uc3Qge2xlbmd0aH0gPSBtMVxuICAgICAgcmV0dXJuIG0xLnNsaWNlKDAsIGxlbmd0aCAtIGxlbmd0aCAlIDIpICsgU1BBQ0VcbiAgICB9XG4gIF0sXG5cbiAgLy8gRXNjYXBlIG1ldGFjaGFyYWN0ZXJzXG4gIC8vIHdoaWNoIGlzIHdyaXR0ZW4gZG93biBieSB1c2VycyBidXQgbWVhbnMgc3BlY2lhbCBmb3IgcmVndWxhciBleHByZXNzaW9ucy5cblxuICAvLyA+IFRoZXJlIGFyZSAxMiBjaGFyYWN0ZXJzIHdpdGggc3BlY2lhbCBtZWFuaW5nczpcbiAgLy8gPiAtIHRoZSBiYWNrc2xhc2ggXFwsXG4gIC8vID4gLSB0aGUgY2FyZXQgXixcbiAgLy8gPiAtIHRoZSBkb2xsYXIgc2lnbiAkLFxuICAvLyA+IC0gdGhlIHBlcmlvZCBvciBkb3QgLixcbiAgLy8gPiAtIHRoZSB2ZXJ0aWNhbCBiYXIgb3IgcGlwZSBzeW1ib2wgfCxcbiAgLy8gPiAtIHRoZSBxdWVzdGlvbiBtYXJrID8sXG4gIC8vID4gLSB0aGUgYXN0ZXJpc2sgb3Igc3RhciAqLFxuICAvLyA+IC0gdGhlIHBsdXMgc2lnbiArLFxuICAvLyA+IC0gdGhlIG9wZW5pbmcgcGFyZW50aGVzaXMgKCxcbiAgLy8gPiAtIHRoZSBjbG9zaW5nIHBhcmVudGhlc2lzICksXG4gIC8vID4gLSBhbmQgdGhlIG9wZW5pbmcgc3F1YXJlIGJyYWNrZXQgWyxcbiAgLy8gPiAtIHRoZSBvcGVuaW5nIGN1cmx5IGJyYWNlIHssXG4gIC8vID4gVGhlc2Ugc3BlY2lhbCBjaGFyYWN0ZXJzIGFyZSBvZnRlbiBjYWxsZWQgXCJtZXRhY2hhcmFjdGVyc1wiLlxuICBbXG4gICAgL1tcXFxcJC58KisoKXteXS9nLFxuICAgIG1hdGNoID0+IGBcXFxcJHttYXRjaH1gXG4gIF0sXG5cbiAgW1xuICAgIC8vID4gYSBxdWVzdGlvbiBtYXJrICg/KSBtYXRjaGVzIGEgc2luZ2xlIGNoYXJhY3RlclxuICAgIC8oPyFcXFxcKVxcPy9nLFxuICAgICgpID0+ICdbXi9dJ1xuICBdLFxuXG4gIC8vIGxlYWRpbmcgc2xhc2hcbiAgW1xuXG4gICAgLy8gPiBBIGxlYWRpbmcgc2xhc2ggbWF0Y2hlcyB0aGUgYmVnaW5uaW5nIG9mIHRoZSBwYXRobmFtZS5cbiAgICAvLyA+IEZvciBleGFtcGxlLCBcIi8qLmNcIiBtYXRjaGVzIFwiY2F0LWZpbGUuY1wiIGJ1dCBub3QgXCJtb3ppbGxhLXNoYTEvc2hhMS5jXCIuXG4gICAgLy8gQSBsZWFkaW5nIHNsYXNoIG1hdGNoZXMgdGhlIGJlZ2lubmluZyBvZiB0aGUgcGF0aG5hbWVcbiAgICAvXlxcLy8sXG4gICAgKCkgPT4gJ14nXG4gIF0sXG5cbiAgLy8gcmVwbGFjZSBzcGVjaWFsIG1ldGFjaGFyYWN0ZXIgc2xhc2ggYWZ0ZXIgdGhlIGxlYWRpbmcgc2xhc2hcbiAgW1xuICAgIC9cXC8vZyxcbiAgICAoKSA9PiAnXFxcXC8nXG4gIF0sXG5cbiAgW1xuICAgIC8vID4gQSBsZWFkaW5nIFwiKipcIiBmb2xsb3dlZCBieSBhIHNsYXNoIG1lYW5zIG1hdGNoIGluIGFsbCBkaXJlY3Rvcmllcy5cbiAgICAvLyA+IEZvciBleGFtcGxlLCBcIioqL2Zvb1wiIG1hdGNoZXMgZmlsZSBvciBkaXJlY3RvcnkgXCJmb29cIiBhbnl3aGVyZSxcbiAgICAvLyA+IHRoZSBzYW1lIGFzIHBhdHRlcm4gXCJmb29cIi5cbiAgICAvLyA+IFwiKiovZm9vL2JhclwiIG1hdGNoZXMgZmlsZSBvciBkaXJlY3RvcnkgXCJiYXJcIiBhbnl3aGVyZSB0aGF0IGlzIGRpcmVjdGx5XG4gICAgLy8gPiAgIHVuZGVyIGRpcmVjdG9yeSBcImZvb1wiLlxuICAgIC8vIE5vdGljZSB0aGF0IHRoZSAnKidzIGhhdmUgYmVlbiByZXBsYWNlZCBhcyAnXFxcXConXG4gICAgL15cXF4qXFxcXFxcKlxcXFxcXCpcXFxcXFwvLyxcblxuICAgIC8vICcqKi9mb28nIDwtPiAnZm9vJ1xuICAgICgpID0+ICdeKD86LipcXFxcLyk/J1xuICBdLFxuXG4gIC8vIHN0YXJ0aW5nXG4gIFtcbiAgICAvLyB0aGVyZSB3aWxsIGJlIG5vIGxlYWRpbmcgJy8nXG4gICAgLy8gICAod2hpY2ggaGFzIGJlZW4gcmVwbGFjZWQgYnkgc2VjdGlvbiBcImxlYWRpbmcgc2xhc2hcIilcbiAgICAvLyBJZiBzdGFydHMgd2l0aCAnKionLCBhZGRpbmcgYSAnXicgdG8gdGhlIHJlZ3VsYXIgZXhwcmVzc2lvbiBhbHNvIHdvcmtzXG4gICAgL14oPz1bXl5dKS8sXG4gICAgZnVuY3Rpb24gc3RhcnRpbmdSZXBsYWNlciAoKSB7XG4gICAgICAvLyBJZiBoYXMgYSBzbGFzaCBgL2AgYXQgdGhlIGJlZ2lubmluZyBvciBtaWRkbGVcbiAgICAgIHJldHVybiAhL1xcLyg/ISQpLy50ZXN0KHRoaXMpXG4gICAgICAgIC8vID4gUHJpb3IgdG8gMi4yMi4xXG4gICAgICAgIC8vID4gSWYgdGhlIHBhdHRlcm4gZG9lcyBub3QgY29udGFpbiBhIHNsYXNoIC8sXG4gICAgICAgIC8vID4gICBHaXQgdHJlYXRzIGl0IGFzIGEgc2hlbGwgZ2xvYiBwYXR0ZXJuXG4gICAgICAgIC8vIEFjdHVhbGx5LCBpZiB0aGVyZSBpcyBvbmx5IGEgdHJhaWxpbmcgc2xhc2gsXG4gICAgICAgIC8vICAgZ2l0IGFsc28gdHJlYXRzIGl0IGFzIGEgc2hlbGwgZ2xvYiBwYXR0ZXJuXG5cbiAgICAgICAgLy8gQWZ0ZXIgMi4yMi4xIChjb21wYXRpYmxlIGJ1dCBjbGVhcmVyKVxuICAgICAgICAvLyA+IElmIHRoZXJlIGlzIGEgc2VwYXJhdG9yIGF0IHRoZSBiZWdpbm5pbmcgb3IgbWlkZGxlIChvciBib3RoKVxuICAgICAgICAvLyA+IG9mIHRoZSBwYXR0ZXJuLCB0aGVuIHRoZSBwYXR0ZXJuIGlzIHJlbGF0aXZlIHRvIHRoZSBkaXJlY3RvcnlcbiAgICAgICAgLy8gPiBsZXZlbCBvZiB0aGUgcGFydGljdWxhciAuZ2l0aWdub3JlIGZpbGUgaXRzZWxmLlxuICAgICAgICAvLyA+IE90aGVyd2lzZSB0aGUgcGF0dGVybiBtYXkgYWxzbyBtYXRjaCBhdCBhbnkgbGV2ZWwgYmVsb3dcbiAgICAgICAgLy8gPiB0aGUgLmdpdGlnbm9yZSBsZXZlbC5cbiAgICAgICAgPyAnKD86XnxcXFxcLyknXG5cbiAgICAgICAgLy8gPiBPdGhlcndpc2UsIEdpdCB0cmVhdHMgdGhlIHBhdHRlcm4gYXMgYSBzaGVsbCBnbG9iIHN1aXRhYmxlIGZvclxuICAgICAgICAvLyA+ICAgY29uc3VtcHRpb24gYnkgZm5tYXRjaCgzKVxuICAgICAgICA6ICdeJ1xuICAgIH1cbiAgXSxcblxuICAvLyB0d28gZ2xvYnN0YXJzXG4gIFtcbiAgICAvLyBVc2UgbG9va2FoZWFkIGFzc2VydGlvbnMgc28gdGhhdCB3ZSBjb3VsZCBtYXRjaCBtb3JlIHRoYW4gb25lIGAnLyoqJ2BcbiAgICAvXFxcXFxcL1xcXFxcXCpcXFxcXFwqKD89XFxcXFxcL3wkKS9nLFxuXG4gICAgLy8gWmVybywgb25lIG9yIHNldmVyYWwgZGlyZWN0b3JpZXNcbiAgICAvLyBzaG91bGQgbm90IHVzZSAnKicsIG9yIGl0IHdpbGwgYmUgcmVwbGFjZWQgYnkgdGhlIG5leHQgcmVwbGFjZXJcblxuICAgIC8vIENoZWNrIGlmIGl0IGlzIG5vdCB0aGUgbGFzdCBgJy8qKidgXG4gICAgKF8sIGluZGV4LCBzdHIpID0+IGluZGV4ICsgNiA8IHN0ci5sZW5ndGhcblxuICAgICAgLy8gY2FzZTogLyoqL1xuICAgICAgLy8gPiBBIHNsYXNoIGZvbGxvd2VkIGJ5IHR3byBjb25zZWN1dGl2ZSBhc3Rlcmlza3MgdGhlbiBhIHNsYXNoIG1hdGNoZXNcbiAgICAgIC8vID4gICB6ZXJvIG9yIG1vcmUgZGlyZWN0b3JpZXMuXG4gICAgICAvLyA+IEZvciBleGFtcGxlLCBcImEvKiovYlwiIG1hdGNoZXMgXCJhL2JcIiwgXCJhL3gvYlwiLCBcImEveC95L2JcIiBhbmQgc28gb24uXG4gICAgICAvLyAnLyoqLydcbiAgICAgID8gJyg/OlxcXFwvW15cXFxcL10rKSonXG5cbiAgICAgIC8vIGNhc2U6IC8qKlxuICAgICAgLy8gPiBBIHRyYWlsaW5nIGBcIi8qKlwiYCBtYXRjaGVzIGV2ZXJ5dGhpbmcgaW5zaWRlLlxuXG4gICAgICAvLyAjMjE6IGV2ZXJ5dGhpbmcgaW5zaWRlIGJ1dCBpdCBzaG91bGQgbm90IGluY2x1ZGUgdGhlIGN1cnJlbnQgZm9sZGVyXG4gICAgICA6ICdcXFxcLy4rJ1xuICBdLFxuXG4gIC8vIG5vcm1hbCBpbnRlcm1lZGlhdGUgd2lsZGNhcmRzXG4gIFtcbiAgICAvLyBOZXZlciByZXBsYWNlIGVzY2FwZWQgJyonXG4gICAgLy8gaWdub3JlIHJ1bGUgJ1xcKicgd2lsbCBtYXRjaCB0aGUgcGF0aCAnKidcblxuICAgIC8vICdhYmMuKi8nIC0+IGdvXG4gICAgLy8gJ2FiYy4qJyAgLT4gc2tpcCB0aGlzIHJ1bGUsXG4gICAgLy8gICAgY296IHRyYWlsaW5nIHNpbmdsZSB3aWxkY2FyZCB3aWxsIGJlIGhhbmRlZCBieSBbdHJhaWxpbmcgd2lsZGNhcmRdXG4gICAgLyhefFteXFxcXF0rKShcXFxcXFwqKSsoPz0uKykvZyxcblxuICAgIC8vICcqLmpzJyBtYXRjaGVzICcuanMnXG4gICAgLy8gJyouanMnIGRvZXNuJ3QgbWF0Y2ggJ2FiYydcbiAgICAoXywgcDEsIHAyKSA9PiB7XG4gICAgICAvLyAxLlxuICAgICAgLy8gPiBBbiBhc3RlcmlzayBcIipcIiBtYXRjaGVzIGFueXRoaW5nIGV4Y2VwdCBhIHNsYXNoLlxuICAgICAgLy8gMi5cbiAgICAgIC8vID4gT3RoZXIgY29uc2VjdXRpdmUgYXN0ZXJpc2tzIGFyZSBjb25zaWRlcmVkIHJlZ3VsYXIgYXN0ZXJpc2tzXG4gICAgICAvLyA+IGFuZCB3aWxsIG1hdGNoIGFjY29yZGluZyB0byB0aGUgcHJldmlvdXMgcnVsZXMuXG4gICAgICBjb25zdCB1bmVzY2FwZWQgPSBwMi5yZXBsYWNlKC9cXFxcXFwqL2csICdbXlxcXFwvXSonKVxuICAgICAgcmV0dXJuIHAxICsgdW5lc2NhcGVkXG4gICAgfVxuICBdLFxuXG4gIFtcbiAgICAvLyB1bmVzY2FwZSwgcmV2ZXJ0IHN0ZXAgMyBleGNlcHQgZm9yIGJhY2sgc2xhc2hcbiAgICAvLyBGb3IgZXhhbXBsZSwgaWYgYSB1c2VyIGVzY2FwZSBhICdcXFxcKicsXG4gICAgLy8gYWZ0ZXIgc3RlcCAzLCB0aGUgcmVzdWx0IHdpbGwgYmUgJ1xcXFxcXFxcXFxcXConXG4gICAgL1xcXFxcXFxcXFxcXCg/PVskLnwqKygpe15dKS9nLFxuICAgICgpID0+IEVTQ0FQRVxuICBdLFxuXG4gIFtcbiAgICAvLyAnXFxcXFxcXFwnIC0+ICdcXFxcJ1xuICAgIC9cXFxcXFxcXC9nLFxuICAgICgpID0+IEVTQ0FQRVxuICBdLFxuXG4gIFtcbiAgICAvLyA+IFRoZSByYW5nZSBub3RhdGlvbiwgZS5nLiBbYS16QS1aXSxcbiAgICAvLyA+IGNhbiBiZSB1c2VkIHRvIG1hdGNoIG9uZSBvZiB0aGUgY2hhcmFjdGVycyBpbiBhIHJhbmdlLlxuXG4gICAgLy8gYFxcYCBpcyBlc2NhcGVkIGJ5IHN0ZXAgM1xuICAgIC8oXFxcXCk/XFxbKFteXFxdL10qPykoXFxcXCopKCR8XFxdKS9nLFxuICAgIChtYXRjaCwgbGVhZEVzY2FwZSwgcmFuZ2UsIGVuZEVzY2FwZSwgY2xvc2UpID0+IGxlYWRFc2NhcGUgPT09IEVTQ0FQRVxuICAgICAgLy8gJ1xcXFxbYmFyXScgLT4gJ1xcXFxcXFxcW2JhclxcXFxdJ1xuICAgICAgPyBgXFxcXFske3JhbmdlfSR7Y2xlYW5SYW5nZUJhY2tTbGFzaChlbmRFc2NhcGUpfSR7Y2xvc2V9YFxuICAgICAgOiBjbG9zZSA9PT0gJ10nXG4gICAgICAgID8gZW5kRXNjYXBlLmxlbmd0aCAlIDIgPT09IDBcbiAgICAgICAgICAvLyBBIG5vcm1hbCBjYXNlLCBhbmQgaXQgaXMgYSByYW5nZSBub3RhdGlvblxuICAgICAgICAgIC8vICdbYmFyXSdcbiAgICAgICAgICAvLyAnW2JhclxcXFxcXFxcXSdcbiAgICAgICAgICA/IGBbJHtzYW5pdGl6ZVJhbmdlKHJhbmdlKX0ke2VuZEVzY2FwZX1dYFxuICAgICAgICAgIC8vIEludmFsaWQgcmFuZ2Ugbm90YXRvblxuICAgICAgICAgIC8vICdbYmFyXFxcXF0nIC0+ICdbYmFyXFxcXFxcXFxdJ1xuICAgICAgICAgIDogJ1tdJ1xuICAgICAgICA6ICdbXSdcbiAgXSxcblxuICAvLyBlbmRpbmdcbiAgW1xuICAgIC8vICdqcycgd2lsbCBub3QgbWF0Y2ggJ2pzLidcbiAgICAvLyAnYWInIHdpbGwgbm90IG1hdGNoICdhYmMnXG4gICAgLyg/OlteKl0pJC8sXG5cbiAgICAvLyBXVEYhXG4gICAgLy8gaHR0cHM6Ly9naXQtc2NtLmNvbS9kb2NzL2dpdGlnbm9yZVxuICAgIC8vIGNoYW5nZXMgaW4gWzIuMjIuMV0oaHR0cHM6Ly9naXQtc2NtLmNvbS9kb2NzL2dpdGlnbm9yZS8yLjIyLjEpXG4gICAgLy8gd2hpY2ggcmUtZml4ZXMgIzI0LCAjMzhcblxuICAgIC8vID4gSWYgdGhlcmUgaXMgYSBzZXBhcmF0b3IgYXQgdGhlIGVuZCBvZiB0aGUgcGF0dGVybiB0aGVuIHRoZSBwYXR0ZXJuXG4gICAgLy8gPiB3aWxsIG9ubHkgbWF0Y2ggZGlyZWN0b3JpZXMsIG90aGVyd2lzZSB0aGUgcGF0dGVybiBjYW4gbWF0Y2ggYm90aFxuICAgIC8vID4gZmlsZXMgYW5kIGRpcmVjdG9yaWVzLlxuXG4gICAgLy8gJ2pzKicgd2lsbCBub3QgbWF0Y2ggJ2EuanMnXG4gICAgLy8gJ2pzLycgd2lsbCBub3QgbWF0Y2ggJ2EuanMnXG4gICAgLy8gJ2pzJyB3aWxsIG1hdGNoICdhLmpzJyBhbmQgJ2EuanMvJ1xuICAgIG1hdGNoID0+IC9cXC8kLy50ZXN0KG1hdGNoKVxuICAgICAgLy8gZm9vLyB3aWxsIG5vdCBtYXRjaCAnZm9vJ1xuICAgICAgPyBgJHttYXRjaH0kYFxuICAgICAgLy8gZm9vIG1hdGNoZXMgJ2ZvbycgYW5kICdmb28vJ1xuICAgICAgOiBgJHttYXRjaH0oPz0kfFxcXFwvJClgXG4gIF0sXG5cbiAgLy8gdHJhaWxpbmcgd2lsZGNhcmRcbiAgW1xuICAgIC8oXFxefFxcXFxcXC8pP1xcXFxcXCokLyxcbiAgICAoXywgcDEpID0+IHtcbiAgICAgIGNvbnN0IHByZWZpeCA9IHAxXG4gICAgICAgIC8vICdcXF4nOlxuICAgICAgICAvLyAnLyonIGRvZXMgbm90IG1hdGNoIEVNUFRZXG4gICAgICAgIC8vICcvKicgZG9lcyBub3QgbWF0Y2ggZXZlcnl0aGluZ1xuXG4gICAgICAgIC8vICdcXFxcXFwvJzpcbiAgICAgICAgLy8gJ2FiYy8qJyBkb2VzIG5vdCBtYXRjaCAnYWJjLydcbiAgICAgICAgPyBgJHtwMX1bXi9dK2BcblxuICAgICAgICAvLyAnYSonIG1hdGNoZXMgJ2EnXG4gICAgICAgIC8vICdhKicgbWF0Y2hlcyAnYWEnXG4gICAgICAgIDogJ1teL10qJ1xuXG4gICAgICByZXR1cm4gYCR7cHJlZml4fSg/PSR8XFxcXC8kKWBcbiAgICB9XG4gIF0sXG5dXG5cbi8vIEEgc2ltcGxlIGNhY2hlLCBiZWNhdXNlIGFuIGlnbm9yZSBydWxlIG9ubHkgaGFzIG9ubHkgb25lIGNlcnRhaW4gbWVhbmluZ1xuY29uc3QgcmVnZXhDYWNoZSA9IE9iamVjdC5jcmVhdGUobnVsbClcblxuLy8gQHBhcmFtIHtwYXR0ZXJufVxuY29uc3QgbWFrZVJlZ2V4ID0gKHBhdHRlcm4sIGlnbm9yZUNhc2UpID0+IHtcbiAgbGV0IHNvdXJjZSA9IHJlZ2V4Q2FjaGVbcGF0dGVybl1cblxuICBpZiAoIXNvdXJjZSkge1xuICAgIHNvdXJjZSA9IFJFUExBQ0VSUy5yZWR1Y2UoXG4gICAgICAocHJldiwgW21hdGNoZXIsIHJlcGxhY2VyXSkgPT5cbiAgICAgICAgcHJldi5yZXBsYWNlKG1hdGNoZXIsIHJlcGxhY2VyLmJpbmQocGF0dGVybikpLFxuICAgICAgcGF0dGVyblxuICAgIClcbiAgICByZWdleENhY2hlW3BhdHRlcm5dID0gc291cmNlXG4gIH1cblxuICByZXR1cm4gaWdub3JlQ2FzZVxuICAgID8gbmV3IFJlZ0V4cChzb3VyY2UsICdpJylcbiAgICA6IG5ldyBSZWdFeHAoc291cmNlKVxufVxuXG5jb25zdCBpc1N0cmluZyA9IHN1YmplY3QgPT4gdHlwZW9mIHN1YmplY3QgPT09ICdzdHJpbmcnXG5cbi8vID4gQSBibGFuayBsaW5lIG1hdGNoZXMgbm8gZmlsZXMsIHNvIGl0IGNhbiBzZXJ2ZSBhcyBhIHNlcGFyYXRvciBmb3IgcmVhZGFiaWxpdHkuXG5jb25zdCBjaGVja1BhdHRlcm4gPSBwYXR0ZXJuID0+IHBhdHRlcm5cbiAgJiYgaXNTdHJpbmcocGF0dGVybilcbiAgJiYgIVJFR0VYX1RFU1RfQkxBTktfTElORS50ZXN0KHBhdHRlcm4pXG4gICYmICFSRUdFWF9JTlZBTElEX1RSQUlMSU5HX0JBQ0tTTEFTSC50ZXN0KHBhdHRlcm4pXG5cbiAgLy8gPiBBIGxpbmUgc3RhcnRpbmcgd2l0aCAjIHNlcnZlcyBhcyBhIGNvbW1lbnQuXG4gICYmIHBhdHRlcm4uaW5kZXhPZignIycpICE9PSAwXG5cbmNvbnN0IHNwbGl0UGF0dGVybiA9IHBhdHRlcm4gPT4gcGF0dGVybi5zcGxpdChSRUdFWF9TUExJVEFMTF9DUkxGKVxuXG5jbGFzcyBJZ25vcmVSdWxlIHtcbiAgY29uc3RydWN0b3IgKFxuICAgIG9yaWdpbixcbiAgICBwYXR0ZXJuLFxuICAgIG5lZ2F0aXZlLFxuICAgIHJlZ2V4XG4gICkge1xuICAgIHRoaXMub3JpZ2luID0gb3JpZ2luXG4gICAgdGhpcy5wYXR0ZXJuID0gcGF0dGVyblxuICAgIHRoaXMubmVnYXRpdmUgPSBuZWdhdGl2ZVxuICAgIHRoaXMucmVnZXggPSByZWdleFxuICB9XG59XG5cbmNvbnN0IGNyZWF0ZVJ1bGUgPSAocGF0dGVybiwgaWdub3JlQ2FzZSkgPT4ge1xuICBjb25zdCBvcmlnaW4gPSBwYXR0ZXJuXG4gIGxldCBuZWdhdGl2ZSA9IGZhbHNlXG5cbiAgLy8gPiBBbiBvcHRpb25hbCBwcmVmaXggXCIhXCIgd2hpY2ggbmVnYXRlcyB0aGUgcGF0dGVybjtcbiAgaWYgKHBhdHRlcm4uaW5kZXhPZignIScpID09PSAwKSB7XG4gICAgbmVnYXRpdmUgPSB0cnVlXG4gICAgcGF0dGVybiA9IHBhdHRlcm4uc3Vic3RyKDEpXG4gIH1cblxuICBwYXR0ZXJuID0gcGF0dGVyblxuICAvLyA+IFB1dCBhIGJhY2tzbGFzaCAoXCJcXFwiKSBpbiBmcm9udCBvZiB0aGUgZmlyc3QgXCIhXCIgZm9yIHBhdHRlcm5zIHRoYXRcbiAgLy8gPiAgIGJlZ2luIHdpdGggYSBsaXRlcmFsIFwiIVwiLCBmb3IgZXhhbXBsZSwgYFwiXFwhaW1wb3J0YW50IS50eHRcImAuXG4gIC5yZXBsYWNlKFJFR0VYX1JFUExBQ0VfTEVBRElOR19FWENBUEVEX0VYQ0xBTUFUSU9OLCAnIScpXG4gIC8vID4gUHV0IGEgYmFja3NsYXNoIChcIlxcXCIpIGluIGZyb250IG9mIHRoZSBmaXJzdCBoYXNoIGZvciBwYXR0ZXJucyB0aGF0XG4gIC8vID4gICBiZWdpbiB3aXRoIGEgaGFzaC5cbiAgLnJlcGxhY2UoUkVHRVhfUkVQTEFDRV9MRUFESU5HX0VYQ0FQRURfSEFTSCwgJyMnKVxuXG4gIGNvbnN0IHJlZ2V4ID0gbWFrZVJlZ2V4KHBhdHRlcm4sIGlnbm9yZUNhc2UpXG5cbiAgcmV0dXJuIG5ldyBJZ25vcmVSdWxlKFxuICAgIG9yaWdpbixcbiAgICBwYXR0ZXJuLFxuICAgIG5lZ2F0aXZlLFxuICAgIHJlZ2V4XG4gIClcbn1cblxuY29uc3QgdGhyb3dFcnJvciA9IChtZXNzYWdlLCBDdG9yKSA9PiB7XG4gIHRocm93IG5ldyBDdG9yKG1lc3NhZ2UpXG59XG5cbmNvbnN0IGNoZWNrUGF0aCA9IChwYXRoLCBvcmlnaW5hbFBhdGgsIGRvVGhyb3cpID0+IHtcbiAgaWYgKCFpc1N0cmluZyhwYXRoKSkge1xuICAgIHJldHVybiBkb1Rocm93KFxuICAgICAgYHBhdGggbXVzdCBiZSBhIHN0cmluZywgYnV0IGdvdCBcXGAke29yaWdpbmFsUGF0aH1cXGBgLFxuICAgICAgVHlwZUVycm9yXG4gICAgKVxuICB9XG5cbiAgLy8gV2UgZG9uJ3Qga25vdyBpZiB3ZSBzaG91bGQgaWdub3JlIEVNUFRZLCBzbyB0aHJvd1xuICBpZiAoIXBhdGgpIHtcbiAgICByZXR1cm4gZG9UaHJvdyhgcGF0aCBtdXN0IG5vdCBiZSBlbXB0eWAsIFR5cGVFcnJvcilcbiAgfVxuXG4gIC8vIENoZWNrIGlmIGl0IGlzIGEgcmVsYXRpdmUgcGF0aFxuICBpZiAoY2hlY2tQYXRoLmlzTm90UmVsYXRpdmUocGF0aCkpIHtcbiAgICBjb25zdCByID0gJ2BwYXRoLnJlbGF0aXZlKClgZCdcbiAgICByZXR1cm4gZG9UaHJvdyhcbiAgICAgIGBwYXRoIHNob3VsZCBiZSBhICR7cn0gc3RyaW5nLCBidXQgZ290IFwiJHtvcmlnaW5hbFBhdGh9XCJgLFxuICAgICAgUmFuZ2VFcnJvclxuICAgIClcbiAgfVxuXG4gIHJldHVybiB0cnVlXG59XG5cbmNvbnN0IGlzTm90UmVsYXRpdmUgPSBwYXRoID0+IFJFR0VYX1RFU1RfSU5WQUxJRF9QQVRILnRlc3QocGF0aClcblxuY2hlY2tQYXRoLmlzTm90UmVsYXRpdmUgPSBpc05vdFJlbGF0aXZlXG5jaGVja1BhdGguY29udmVydCA9IHAgPT4gcFxuXG5jbGFzcyBJZ25vcmUge1xuICBjb25zdHJ1Y3RvciAoe1xuICAgIGlnbm9yZWNhc2UgPSB0cnVlLFxuICAgIGlnbm9yZUNhc2UgPSBpZ25vcmVjYXNlLFxuICAgIGFsbG93UmVsYXRpdmVQYXRocyA9IGZhbHNlXG4gIH0gPSB7fSkge1xuICAgIGRlZmluZSh0aGlzLCBLRVlfSUdOT1JFLCB0cnVlKVxuXG4gICAgdGhpcy5fcnVsZXMgPSBbXVxuICAgIHRoaXMuX2lnbm9yZUNhc2UgPSBpZ25vcmVDYXNlXG4gICAgdGhpcy5fYWxsb3dSZWxhdGl2ZVBhdGhzID0gYWxsb3dSZWxhdGl2ZVBhdGhzXG4gICAgdGhpcy5faW5pdENhY2hlKClcbiAgfVxuXG4gIF9pbml0Q2FjaGUgKCkge1xuICAgIHRoaXMuX2lnbm9yZUNhY2hlID0gT2JqZWN0LmNyZWF0ZShudWxsKVxuICAgIHRoaXMuX3Rlc3RDYWNoZSA9IE9iamVjdC5jcmVhdGUobnVsbClcbiAgfVxuXG4gIF9hZGRQYXR0ZXJuIChwYXR0ZXJuKSB7XG4gICAgLy8gIzMyXG4gICAgaWYgKHBhdHRlcm4gJiYgcGF0dGVybltLRVlfSUdOT1JFXSkge1xuICAgICAgdGhpcy5fcnVsZXMgPSB0aGlzLl9ydWxlcy5jb25jYXQocGF0dGVybi5fcnVsZXMpXG4gICAgICB0aGlzLl9hZGRlZCA9IHRydWVcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIGlmIChjaGVja1BhdHRlcm4ocGF0dGVybikpIHtcbiAgICAgIGNvbnN0IHJ1bGUgPSBjcmVhdGVSdWxlKHBhdHRlcm4sIHRoaXMuX2lnbm9yZUNhc2UpXG4gICAgICB0aGlzLl9hZGRlZCA9IHRydWVcbiAgICAgIHRoaXMuX3J1bGVzLnB1c2gocnVsZSlcbiAgICB9XG4gIH1cblxuICAvLyBAcGFyYW0ge0FycmF5PHN0cmluZz4gfCBzdHJpbmcgfCBJZ25vcmV9IHBhdHRlcm5cbiAgYWRkIChwYXR0ZXJuKSB7XG4gICAgdGhpcy5fYWRkZWQgPSBmYWxzZVxuXG4gICAgbWFrZUFycmF5KFxuICAgICAgaXNTdHJpbmcocGF0dGVybilcbiAgICAgICAgPyBzcGxpdFBhdHRlcm4ocGF0dGVybilcbiAgICAgICAgOiBwYXR0ZXJuXG4gICAgKS5mb3JFYWNoKHRoaXMuX2FkZFBhdHRlcm4sIHRoaXMpXG5cbiAgICAvLyBTb21lIHJ1bGVzIGhhdmUganVzdCBhZGRlZCB0byB0aGUgaWdub3JlLFxuICAgIC8vIG1ha2luZyB0aGUgYmVoYXZpb3IgY2hhbmdlZC5cbiAgICBpZiAodGhpcy5fYWRkZWQpIHtcbiAgICAgIHRoaXMuX2luaXRDYWNoZSgpXG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXNcbiAgfVxuXG4gIC8vIGxlZ2FjeVxuICBhZGRQYXR0ZXJuIChwYXR0ZXJuKSB7XG4gICAgcmV0dXJuIHRoaXMuYWRkKHBhdHRlcm4pXG4gIH1cblxuICAvLyAgICAgICAgICB8ICAgICAgICAgICBpZ25vcmVkIDogdW5pZ25vcmVkXG4gIC8vIG5lZ2F0aXZlIHwgICAwOjAgICB8ICAgMDoxICAgfCAgIDE6MCAgIHwgICAxOjFcbiAgLy8gLS0tLS0tLS0gfCAtLS0tLS0tIHwgLS0tLS0tLSB8IC0tLS0tLS0gfCAtLS0tLS0tLVxuICAvLyAgICAgMCAgICB8ICBURVNUICAgfCAgVEVTVCAgIHwgIFNLSVAgICB8ICAgIFhcbiAgLy8gICAgIDEgICAgfCAgVEVTVElGIHwgIFNLSVAgICB8ICBURVNUICAgfCAgICBYXG5cbiAgLy8gLSBTS0lQOiBhbHdheXMgc2tpcFxuICAvLyAtIFRFU1Q6IGFsd2F5cyB0ZXN0XG4gIC8vIC0gVEVTVElGOiBvbmx5IHRlc3QgaWYgY2hlY2tVbmlnbm9yZWRcbiAgLy8gLSBYOiB0aGF0IG5ldmVyIGhhcHBlblxuXG4gIC8vIEBwYXJhbSB7Ym9vbGVhbn0gd2hldGhlciBzaG91bGQgY2hlY2sgaWYgdGhlIHBhdGggaXMgdW5pZ25vcmVkLFxuICAvLyAgIHNldHRpbmcgYGNoZWNrVW5pZ25vcmVkYCB0byBgZmFsc2VgIGNvdWxkIHJlZHVjZSBhZGRpdGlvbmFsXG4gIC8vICAgcGF0aCBtYXRjaGluZy5cblxuICAvLyBAcmV0dXJucyB7VGVzdFJlc3VsdH0gdHJ1ZSBpZiBhIGZpbGUgaXMgaWdub3JlZFxuICBfdGVzdE9uZSAocGF0aCwgY2hlY2tVbmlnbm9yZWQpIHtcbiAgICBsZXQgaWdub3JlZCA9IGZhbHNlXG4gICAgbGV0IHVuaWdub3JlZCA9IGZhbHNlXG5cbiAgICB0aGlzLl9ydWxlcy5mb3JFYWNoKHJ1bGUgPT4ge1xuICAgICAgY29uc3Qge25lZ2F0aXZlfSA9IHJ1bGVcbiAgICAgIGlmIChcbiAgICAgICAgdW5pZ25vcmVkID09PSBuZWdhdGl2ZSAmJiBpZ25vcmVkICE9PSB1bmlnbm9yZWRcbiAgICAgICAgfHwgbmVnYXRpdmUgJiYgIWlnbm9yZWQgJiYgIXVuaWdub3JlZCAmJiAhY2hlY2tVbmlnbm9yZWRcbiAgICAgICkge1xuICAgICAgICByZXR1cm5cbiAgICAgIH1cblxuICAgICAgY29uc3QgbWF0Y2hlZCA9IHJ1bGUucmVnZXgudGVzdChwYXRoKVxuXG4gICAgICBpZiAobWF0Y2hlZCkge1xuICAgICAgICBpZ25vcmVkID0gIW5lZ2F0aXZlXG4gICAgICAgIHVuaWdub3JlZCA9IG5lZ2F0aXZlXG4gICAgICB9XG4gICAgfSlcblxuICAgIHJldHVybiB7XG4gICAgICBpZ25vcmVkLFxuICAgICAgdW5pZ25vcmVkXG4gICAgfVxuICB9XG5cbiAgLy8gQHJldHVybnMge1Rlc3RSZXN1bHR9XG4gIF90ZXN0IChvcmlnaW5hbFBhdGgsIGNhY2hlLCBjaGVja1VuaWdub3JlZCwgc2xpY2VzKSB7XG4gICAgY29uc3QgcGF0aCA9IG9yaWdpbmFsUGF0aFxuICAgICAgLy8gU3VwcG9ydHMgbnVsbGFibGUgcGF0aFxuICAgICAgJiYgY2hlY2tQYXRoLmNvbnZlcnQob3JpZ2luYWxQYXRoKVxuXG4gICAgY2hlY2tQYXRoKFxuICAgICAgcGF0aCxcbiAgICAgIG9yaWdpbmFsUGF0aCxcbiAgICAgIHRoaXMuX2FsbG93UmVsYXRpdmVQYXRoc1xuICAgICAgICA/IFJFVFVSTl9GQUxTRVxuICAgICAgICA6IHRocm93RXJyb3JcbiAgICApXG5cbiAgICByZXR1cm4gdGhpcy5fdChwYXRoLCBjYWNoZSwgY2hlY2tVbmlnbm9yZWQsIHNsaWNlcylcbiAgfVxuXG4gIF90IChwYXRoLCBjYWNoZSwgY2hlY2tVbmlnbm9yZWQsIHNsaWNlcykge1xuICAgIGlmIChwYXRoIGluIGNhY2hlKSB7XG4gICAgICByZXR1cm4gY2FjaGVbcGF0aF1cbiAgICB9XG5cbiAgICBpZiAoIXNsaWNlcykge1xuICAgICAgLy8gcGF0aC90by9hLmpzXG4gICAgICAvLyBbJ3BhdGgnLCAndG8nLCAnYS5qcyddXG4gICAgICBzbGljZXMgPSBwYXRoLnNwbGl0KFNMQVNIKVxuICAgIH1cblxuICAgIHNsaWNlcy5wb3AoKVxuXG4gICAgLy8gSWYgdGhlIHBhdGggaGFzIG5vIHBhcmVudCBkaXJlY3RvcnksIGp1c3QgdGVzdCBpdFxuICAgIGlmICghc2xpY2VzLmxlbmd0aCkge1xuICAgICAgcmV0dXJuIGNhY2hlW3BhdGhdID0gdGhpcy5fdGVzdE9uZShwYXRoLCBjaGVja1VuaWdub3JlZClcbiAgICB9XG5cbiAgICBjb25zdCBwYXJlbnQgPSB0aGlzLl90KFxuICAgICAgc2xpY2VzLmpvaW4oU0xBU0gpICsgU0xBU0gsXG4gICAgICBjYWNoZSxcbiAgICAgIGNoZWNrVW5pZ25vcmVkLFxuICAgICAgc2xpY2VzXG4gICAgKVxuXG4gICAgLy8gSWYgdGhlIHBhdGggY29udGFpbnMgYSBwYXJlbnQgZGlyZWN0b3J5LCBjaGVjayB0aGUgcGFyZW50IGZpcnN0XG4gICAgcmV0dXJuIGNhY2hlW3BhdGhdID0gcGFyZW50Lmlnbm9yZWRcbiAgICAgIC8vID4gSXQgaXMgbm90IHBvc3NpYmxlIHRvIHJlLWluY2x1ZGUgYSBmaWxlIGlmIGEgcGFyZW50IGRpcmVjdG9yeSBvZlxuICAgICAgLy8gPiAgIHRoYXQgZmlsZSBpcyBleGNsdWRlZC5cbiAgICAgID8gcGFyZW50XG4gICAgICA6IHRoaXMuX3Rlc3RPbmUocGF0aCwgY2hlY2tVbmlnbm9yZWQpXG4gIH1cblxuICBpZ25vcmVzIChwYXRoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3Rlc3QocGF0aCwgdGhpcy5faWdub3JlQ2FjaGUsIGZhbHNlKS5pZ25vcmVkXG4gIH1cblxuICBjcmVhdGVGaWx0ZXIgKCkge1xuICAgIHJldHVybiBwYXRoID0+ICF0aGlzLmlnbm9yZXMocGF0aClcbiAgfVxuXG4gIGZpbHRlciAocGF0aHMpIHtcbiAgICByZXR1cm4gbWFrZUFycmF5KHBhdGhzKS5maWx0ZXIodGhpcy5jcmVhdGVGaWx0ZXIoKSlcbiAgfVxuXG4gIC8vIEByZXR1cm5zIHtUZXN0UmVzdWx0fVxuICB0ZXN0IChwYXRoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3Rlc3QocGF0aCwgdGhpcy5fdGVzdENhY2hlLCB0cnVlKVxuICB9XG59XG5cbmNvbnN0IGZhY3RvcnkgPSBvcHRpb25zID0+IG5ldyBJZ25vcmUob3B0aW9ucylcblxuY29uc3QgaXNQYXRoVmFsaWQgPSBwYXRoID0+XG4gIGNoZWNrUGF0aChwYXRoICYmIGNoZWNrUGF0aC5jb252ZXJ0KHBhdGgpLCBwYXRoLCBSRVRVUk5fRkFMU0UpXG5cbmZhY3RvcnkuaXNQYXRoVmFsaWQgPSBpc1BhdGhWYWxpZFxuXG4vLyBGaXhlcyB0eXBlc2NyaXB0XG5mYWN0b3J5LmRlZmF1bHQgPSBmYWN0b3J5XG5cbm1vZHVsZS5leHBvcnRzID0gZmFjdG9yeVxuXG4vLyBXaW5kb3dzXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuLyogaXN0YW5idWwgaWdub3JlIGlmICovXG5pZiAoXG4gIC8vIERldGVjdCBgcHJvY2Vzc2Agc28gdGhhdCBpdCBjYW4gcnVuIGluIGJyb3dzZXJzLlxuICB0eXBlb2YgcHJvY2VzcyAhPT0gJ3VuZGVmaW5lZCdcbiAgJiYgKFxuICAgIHByb2Nlc3MuZW52ICYmIHByb2Nlc3MuZW52LklHTk9SRV9URVNUX1dJTjMyXG4gICAgfHwgcHJvY2Vzcy5wbGF0Zm9ybSA9PT0gJ3dpbjMyJ1xuICApXG4pIHtcbiAgLyogZXNsaW50IG5vLWNvbnRyb2wtcmVnZXg6IFwib2ZmXCIgKi9cbiAgY29uc3QgbWFrZVBvc2l4ID0gc3RyID0+IC9eXFxcXFxcXFxcXD9cXFxcLy50ZXN0KHN0cilcbiAgfHwgL1tcIjw+fFxcdTAwMDAtXFx1MDAxRl0rL3UudGVzdChzdHIpXG4gICAgPyBzdHJcbiAgICA6IHN0ci5yZXBsYWNlKC9cXFxcL2csICcvJylcblxuICBjaGVja1BhdGguY29udmVydCA9IG1ha2VQb3NpeFxuXG4gIC8vICdDOlxcXFxmb28nICAgICA8LSAnQzpcXFxcZm9vJyBoYXMgYmVlbiBjb252ZXJ0ZWQgdG8gJ0M6LydcbiAgLy8gJ2Q6XFxcXGZvbydcbiAgY29uc3QgUkVHSVhfSVNfV0lORE9XU19QQVRIX0FCU09MVVRFID0gL15bYS16XTpcXC8vaVxuICBjaGVja1BhdGguaXNOb3RSZWxhdGl2ZSA9IHBhdGggPT5cbiAgICBSRUdJWF9JU19XSU5ET1dTX1BBVEhfQUJTT0xVVEUudGVzdChwYXRoKVxuICAgIHx8IGlzTm90UmVsYXRpdmUocGF0aClcbn1cbiJdLAogICJtYXBwaW5ncyI6ICI7Ozs7OztBQUFBO0FBQUE7QUFDQSxhQUFTLFVBQVcsU0FBUztBQUMzQixhQUFPLE1BQU0sUUFBUSxPQUFPLElBQ3hCLFVBQ0EsQ0FBQyxPQUFPO0FBQUEsSUFDZDtBQUVBLFFBQU0sUUFBUTtBQUNkLFFBQU0sUUFBUTtBQUNkLFFBQU0sU0FBUztBQUNmLFFBQU0sd0JBQXdCO0FBQzlCLFFBQU0sbUNBQW1DO0FBQ3pDLFFBQU0sNENBQTRDO0FBQ2xELFFBQU0scUNBQXFDO0FBQzNDLFFBQU0sc0JBQXNCO0FBTTVCLFFBQU0sMEJBQTBCO0FBRWhDLFFBQU0sUUFBUTtBQUdkLFFBQUksaUJBQWlCO0FBRXJCLFFBQUksT0FBTyxXQUFXLGFBQWE7QUFDakMsdUJBQWlCLE9BQU8sSUFB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
