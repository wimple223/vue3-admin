var __getOwnPropNames = Object.getOwnPropertyNames;
var __commonJS = (cb, mod) => function __require() {
  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};

// node_modules/ignore/legacy.js
var require_legacy = __commonJS({
  "node_modules/ignore/legacy.js"(exports, module) {
    function _typeof(obj) {
      "@babel/helpers - typeof";
      return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(obj2) {
        return typeof obj2;
      } : function(obj2) {
        return obj2 && "function" == typeof Symbol && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
      }, _typeof(obj);
    }
    function _defineProperties(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor) descriptor.writable = true;
        Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor);
      }
    }
    function _createClass(Constructor, protoProps, staticProps) {
      if (protoProps) _defineProperties(Constructor.prototype, protoProps);
      if (staticProps) _defineProperties(Constructor, staticProps);
      Object.defineProperty(Constructor, "prototype", { writable: false });
      return Constructor;
    }
    function _toPropertyKey(arg) {
      var key = _toPrimitive(arg, "string");
      return _typeof(key) === "symbol" ? key : String(key);
    }
    function _toPrimitive(input, hint) {
      if (_typeof(input) !== "object" || input === null) return input;
      var prim = input[Symbol.toPrimitive];
      if (prim !== void 0) {
        var res = prim.call(input, hint || "default");
        if (_typeof(res) !== "object") return res;
        throw new TypeError("@@toPrimitive must return a primitive value.");
      }
      return (hint === "string" ? String : Number)(input);
    }
    function _classCallCheck(instance, Constructor) {
      if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
      }
    }
    function _slicedToArray(arr, i) {
      return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest();
    }
    function _nonIterableRest() {
      throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
    }
    function _unsupportedIterableToArray(o, minLen) {
      if (!o) return;
      if (typeof o === "string") return _arrayLikeToArray(o, minLen);
      var n = Object.prototype.toString.call(o).slice(8, -1);
      if (n === "Object" && o.constructor) n = o.constructor.name;
      if (n === "Map" || n === "Set") return Array.from(o);
      if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);
    }
    function _arrayLikeToArray(arr, len) {
      if (len == null || len > arr.length) len = arr.length;
      for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];
      return arr2;
    }
    function _iterableToArrayLimit(arr, i) {
      var _i = null == arr ? null : "undefined" != typeof Symbol && arr[Symbol.iterator] || arr["@@iterator"];
      if (null != _i) {
        var _s, _e, _x, _r, _arr = [], _n = true, _d = false;
        try {
          if (_x = (_i = _i.call(arr)).next, 0 === i) {
            if (Object(_i) !== _i) return;
            _n = false;
          } else for (; !(_n = (_s = _x.call(_i)).done) && (_arr.push(_s.value), _arr.length !== i); _n = true) ;
        } catch (err) {
          _d = true, _e = err;
        } finally {
          try {
            if (!_n && null != _i["return"] && (_r = _i["return"](), Object(_r) !== _r)) return;
          } finally {
            if (_d) throw _e;
          }
        }
        return _arr;
      }
    }
    function _arrayWithHoles(arr) {
      if (Array.isArray(arr)) return arr;
    }
    function makeArray(subject) {
      return Array.isArray(subject) ? subject : [subject];
    }
    var EMPTY = "";
    var SPACE = " ";
    var ESCAPE = "\\";
    var REGEX_TEST_BLANK_LINE = /^\s+$/;
    var REGEX_INVALID_TRAILING_BACKSLASH = /(?:[^\\]|^)\\$/;
    var REGEX_REPLACE_LEADING_EXCAPED_EXCLAMATION = /^\\!/;
    var REGEX_REPLACE_LEADING_EXCAPED_HASH = /^\\#/;
    var REGEX_SPLITALL_CRLF = /\r?\n/g;
    var REGEX_TEST_INVALID_PATH = /^\.*\/|^\.+$/;
    var SLASH = "/";
    var TMP_KEY_IGNORE = "node-ignore";
    if (typeof Symbol !== "undefined") {
      TMP_KEY_IGNORE = Symbol["for"]("node-ignore");
    }
    var KEY_IGNORE = TMP_KEY_IGNORE;
    var define = function define2(object, key, value) {
      return Object.defineProperty(object, key, {
        value
      });
    };
    var REGEX_REGEXP_RANGE = /([0-z])-([0-z])/g;
    var RETURN_FALSE = function RETURN_FALSE2() {
      return false;
    };
    var sanitizeRange = function sanitizeRange2(range) {
      return range.replace(REGEX_REGEXP_RANGE, function(match, from, to) {
        return from.charCodeAt(0) <= to.charCodeAt(0) ? match : EMPTY;
      });
    };
    var cleanRangeBackSlash = function cleanRangeBackSlash2(slashes) {
      var length = slashes.length;
      return slashes.slice(0, length - length % 2);
    };
    var REPLACERS = [
      [
        // remove BOM
        // TODO:
        // Other similar zero-width characters?
        /^\uFEFF/,
        function() {
          return EMPTY;
        }
      ],
      // > Trailing spaces are ignored unless they are quoted with backslash ("\")
      [
        // (a\ ) -> (a )
        // (a  ) -> (a)
        // (a ) -> (a)
        // (a \ ) -> (a  )
        /((?:\\\\)*?)(\\?\s+)$/,
        function(_, m1, m2) {
          return m1 + (m2.indexOf("\\") === 0 ? SPACE : EMPTY);
        }
      ],
      // replace (\ ) with ' '
      // (\ ) -> ' '
      // (\\ ) -> '\\ '
      // (\\\ ) -> '\\ '
      [/(\\+?)\s/g, function(_, m1) {
        var length = m1.length;
        return m1.slice(0, length - length % 2) + SPACE;
      }],
      // Escape metacharacters
      // which is written down by users but means special for regular expressions.
      // > There are 12 characters with special meanings:
      // > - the backslash \,
      // > - the caret ^,
      // > - the dollar sign $,
      // > - the period or dot .,
      // > - the vertical bar or pipe symbol |,
      // > - the question mark ?,
      // > - the asterisk or star *,
      // > - the plus sign +,
      // > - the opening parenthesis (,
      // > - the closing parenthesis ),
      // > - and the opening square bracket [,
      // > - the opening curly brace {,
      // > These special characters are often called "metacharacters".
      [/[\\$.|*+(){^]/g, function(match) {
        return "\\".concat(match);
      }],
      [
        // > a question mark (?) matches a single character
        /(?!\\)\?/g,
        function() {
          return "[^/]";
        }
      ],
      // leading slash
      [
        // > A leading slash matches the beginning of the pathname.
        // > For example, "/*.c" matches "cat-file.c" but not "mozilla-sha1/sha1.c".
        // A leading slash matches the beginning of the pathname
        /^\//,
        function() {
          return "^";
        }
      ],
      // replace special metacharacter slash after the leading slash
      [/\//g, function() {
        return "\\/";
      }],
      [
        // > A leading "**" followed by a slash means match in all directories.
        // > For example, "**/foo" matches file or directory "foo" anywhere,
        // > the same as pattern "foo".
        // > "**/foo/bar" matches file or directory "bar" anywhere that is directly
        // >   under directory "foo".
        // Notice that the '*'s have been replaced as '\\*'
        /^\^*\\\*\\\*\\\//,
        // '**/foo' <-> 'foo'
        function() {
          return "^(?:.*\\/)?";
        }
      ],
      // starting
      [
        // there will be no leading '/'
        //   (which has been replaced by section "leading slash")
        // If starts with '**', adding a '^' to the regular expression also works
        /^(?=[^^])/,
        function startingReplacer() {
          return !/\/(?!$)/.test(this) ? "(?:^|\\/)" : "^";
        }
      ],
      // two globstars
      [
        // Use lookahead assertions so that we could match more than one `'/**'`
        /\\\/\\\*\\\*(?=\\\/|$)/g,
        // Zero, one or several directories
        // should not use '*', or it will be replaced by the next replacer
        // Check if it is not the last `'/**'`
        function(_, index, str) {
          return index + 6 < str.length ? "(?:\\/[^\\/]+)*" : "\\/.+";
        }
      ],
      // normal intermediate wildcards
      [
        // Never replace escaped '*'
        // ignore rule '\*' will match the path '*'
        // 'abc.*/' -> go
        // 'abc.*'  -> skip this rule,
        //    coz trailing single wildcard will be handed by [trailing wildcard]
        /(^|[^\\]+)(\\\*)+(?=.+)/g,
        // '*.js' matches '.js'
        // '*.js' doesn't match 'abc'
        function(_, p1, p2) {
          var unescaped = p2.replace(/\\\*/g, "[^\\/]*");
          return p1 + unescaped;
        }
      ],
      [
        // unescape, revert step 3 except for back slash
        // For example, if a user escape a '\\*',
        // after step 3, the result will be '\\\\\\*'
        /\\\\\\(?=[$.|*+(){^])/g,
        function() {
          return ESCAPE;
        }
      ],
      [
        // '\\\\' -> '\\'
        /\\\\/g,
        function() {
          return ESCAPE;
        }
      ],
      [
        // > The range notation, e.g. [a-zA-Z],
        // > can be used to match one of the characters in a range.
        // `\` is escaped by step 3
        /(\\)?\[([^\]/]*?)(\\*)($|\])/g,
        function(match, leadEscape, range, endEscape, close) {
          return leadEscape === ESCAPE ? "\\[".concat(range).concat(cleanRangeBackSlash(endEscape)).concat(close) : close === "]" ? endEscape.length % 2 === 0 ? "[".concat(sanitizeRange(range)).concat(endEscape, "]") : "[]" : "[]";
        }
      ],
      // ending
      [
        // 'js' will not match 'js.'
        // 'ab' will not match 'abc'
        /(?:[^*])$/,
        // WTF!
        // https://git-scm.com/docs/gitignore
        // changes in [2.22.1](https://git-scm.com/docs/gitignore/2.22.1)
        // which re-fixes #24, #38
        // > If there is a separator at the end of the pattern then the pattern
        // > will only match directories, otherwise the pattern can match both
        // > files and directories.
        // 'js*' will not match 'a.js'
        // 'js/' will not match 'a.js'
        // 'js' will match 'a.js' and 'a.js/'
        function(match) {
          return /\/$/.test(match) ? "".concat(match, "$") : "".concat(match, "(?=$|\\/$)");
        }
      ],
      // trailing wildcard
      [/(\^|\\\/)?\\\*$/, function(_, p1) {
        var prefix = p1 ? "".concat(p1, "[^/]+") : "[^/]*";
        return "".concat(prefix, "(?=$|\\/$)");
      }]
    ];
    var regexCache = /* @__PURE__ */ Object.create(null);
    var makeRegex = function makeRegex2(pattern, ignoreCase) {
      var source = regexCache[pattern];
      if (!source) {
        source = REPLACERS.reduce(function(prev, _ref) {
          var _ref2 = _slicedToArray(_ref, 2), matcher = _ref2[0], replacer = _ref2[1];
          return prev.replace(matcher, replacer.bind(pattern));
        }, pattern);
        regexCache[pattern] = source;
      }
      return ignoreCase ? new RegExp(source, "i") : new RegExp(source);
    };
    var isString = function isString2(subject) {
      return typeof subject === "string";
    };
    var checkPattern = function checkPattern2(pattern) {
      return pattern && isString(pattern) && !REGEX_TEST_BLANK_LINE.test(pattern) && !REGEX_INVALID_TRAILING_BACKSLASH.test(pattern) && pattern.indexOf("#") !== 0;
    };
    var splitPattern = function splitPattern2(pattern) {
      return pattern.split(REGEX_SPLITALL_CRLF);
    };
    var IgnoreRule = /* @__PURE__ */ _createClass(function IgnoreRule2(origin, pattern, negative, regex) {
      _classCallCheck(this, IgnoreRule2);
      this.origin = origin;
      this.pattern = pattern;
      this.negative = negative;
      this.regex = regex;
    });
    var createRule = function createRule2(pattern, ignoreCase) {
      var origin = pattern;
      var negative = false;
      if (pattern.indexOf("!") === 0) {
        negative = true;
        pattern = pattern.substr(1);
      }
      pattern = pattern.replace(REGEX_REPLACE_LEADING_EXCAPED_EXCLAMATION, "!").replace(REGEX_REPLACE_LEADING_EXCAPED_HASH, "#");
      var regex = makeRegex(pattern, ignoreCase);
      return new IgnoreRule(origin, pattern, negative, regex);
    };
    var throwError = function throwError2(message, Ctor) {
      throw new Ctor(message);
    };
    var checkPath = function checkPath2(path, originalPath, doThrow) {
      if (!isString(path)) {
        return doThrow("path must be a string, but got `".concat(originalPath, "`"), TypeError);
      }
      if (!path) {
        return doThrow("path must not be empty", TypeError);
      }
      if (checkPath2.isNotRelative(path)) {
        var r = "`path.relative()`d";
        return doThrow("path should be a ".concat(r, ' string, but got "').concat(originalPath, '"'), RangeError);
      }
      return true;
    };
    var isNotRelative = function isNotRelative2(path) {
      return REGEX_TEST_INVALID_PATH.test(path);
    };
    checkPath.isNotRelative = isNotRelative;
    checkPath.convert = function(p) {
      return p;
    };
    var Ignore = /* @__PURE__ */ function() {
      function Ignore2() {
        var _ref3 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}, _ref3$ignorecase = _ref3.ignorecase, ignorecase = _ref3$ignorecase === void 0 ? true : _ref3$ignorecase, _ref3$ignoreCase = _ref3.ignoreCase, ignoreCase = _ref3$ignoreCase === void 0 ? ignorecase : _ref3$ignoreCase, _ref3$allowRelativePa = _ref3.allowRelativePaths, allowRelativePaths = _ref3$allowRelativePa === void 0 ? false : _ref3$allowRelativePa;
        _classCallCheck(this, Ignore2);
        define(this, KEY_IGNORE, true);
        this._rules = [];
        this._ignoreCase = ignoreCase;
        this._allowRelativePaths = allowRelativePaths;
        this._initCache();
      }
      _createClass(Ignore2, [{
        key: "_initCache",
        value: function _initCache() {
          this._ignoreCache = /* @__PURE__ */ Object.create(null);
          this._testCache = /* @__PURE__ */ Object.create(null);
        }
      }, {
        key: "_addPattern",
        value: function _addPattern(pattern) {
          if (pattern && pattern[KEY_IGNORE]) {
            this._rules = this._rules.concat(pattern._rules);
            this._added = true;
            return;
          }
          if (checkPattern(pattern)) {
            var rule = createRule(pattern, this._ignoreCase);
            this._added = true;
            this._rules.push(rule);
          }
        }
        // @param {Array<string> | string | Ignore} pattern
      }, {
        key: "add",
        value: function add(pattern) {
          this._added = false;
          makeArray(isString(pattern) ? splitPattern(pattern) : pattern).forEach(this._addPattern, this);
          if (this._added) {
            this._initCache();
          }
          return this;
        }
        // legacy
      }, {
        key: "addPattern",
        value: function addPattern(pattern) {
          return this.add(pattern);
        }
        //          |           ignored : unignored
        // negative |   0:0   |   0:1   |   1:0   |   1:1
        // -------- | ------- | ------- | ------- | --------
        //     0    |  TEST   |  TEST   |  SKIP   |    X
        //     1    |  TESTIF |  SKIP   |  TEST   |    X
        // - SKIP: always skip
        // - TEST: always test
        // - TESTIF: only test if checkUnignored
        // - X: that never happen
        // @param {boolean} whether should check if the path is unignored,
        //   setting `checkUnignored` to `false` could reduce additional
        //   path matching.
        // @returns {TestResult} true if a file is ignored
      }, {
        key: "_testOne",
        value: function _testOne(path, checkUnignored) {
          var ignored = false;
          var unignored = false;
          this._rules.forEach(function(rule) {
            var negative = rule.negative;
            if (unignored === negative && ignored !== unignored || negative && !ignored && !unignored && !checkUnignored) {
              return;
            }
            var matched = rule.regex.test(path);
            if (matched) {
              ignored = !negative;
              unignored = negative;
            }
          });
          return {
            ignored,
            unignored
          };
        }
        // @returns {TestResult}
      }, {
        key: "_test",
        value: function _test(originalPath, cache, checkUnignored, slices) {
          var path = originalPath && checkPath.convert(originalPath);
          checkPath(path, originalPath, this._allowRelativePaths ? RETURN_FALSE : throwError);
          return this._t(path, cache, checkUnignored, slices);
        }
      }, {
        key: "_t",
        value: function _t(path, cache, checkUnignored, slices) {
          if (path in cache) {
            return cache[path];
          }
          if (!slices) {
            slices = path.split(SLASH);
          }
          slices.pop();
          if (!slices.length) {
            return cache[path] = this._testOne(path, checkUnignored);
          }
          var parent = this._t(slices.join(SLASH) + SLASH, cache, checkUnignored, slices);
          return cache[path] = parent.ignored ? parent : this._testOne(path, checkUnignored);
        }
      }, {
        key: "ignores",
        value: function ignores(path) {
          return this._test(path, this._ignoreCache, false).ignored;
        }
      }, {
        key: "createFilter",
        value: function createFilter() {
          var _this = this;
          return function(path) {
            return !_this.ignores(path);
          };
        }
      }, {
        key: "filter",
        value: function filter(paths) {
          return makeArray(paths).filter(this.createFilter());
        }
        // @returns {TestResult}
      }, {
        key: "test",
        value: function test(path) {
          return this._test(path, this._testCache, true);
        }
      }]);
      return Ignore2;
    }();
    var factory = function factory2(options) {
      return new Ignore(options);
    };
    var isPathValid = function isPathValid2(path) {
      return checkPath(path && checkPath.convert(path), path, RETURN_FALSE);
    };
    factory.isPathValid = isPathValid;
    factory["default"] = factory;
    module.exports = factory;
    if (
      // Detect `process` so that it can run in browsers.
      typeof process !== "undefined" && (process.env && process.env.IGNORE_TEST_WIN32 || process.platform === "win32")
    ) {
      makePosix = function makePosix2(str) {
        return /^\\\\\?\\/.test(str) || /[\0-\x1F"<>\|]+/.test(str) ? str : str.replace(/\\/g, "/");
      };
      checkPath.convert = makePosix;
      REGIX_IS_WINDOWS_PATH_ABSOLUTE = /^[a-z]:\//i;
      checkPath.isNotRelative = function(path) {
        return REGIX_IS_WINDOWS_PATH_ABSOLUTE.test(path) || isNotRelative(path);
      };
    }
    var makePosix;
    var REGIX_IS_WINDOWS_PATH_ABSOLUTE;
  }
});
export default require_legacy();
//# sourceMappingURL=data:application/json;base64,ewogICJ2ZXJzaW9uIjogMywKICAic291cmNlcyI6IFsibm9kZV9tb2R1bGVzL2lnbm9yZS9sZWdhY3kuanMiXSwKICAic291cmNlc0NvbnRlbnQiOiBbImNvbnN0IF9faW5qZWN0ZWRfZmlsZW5hbWVfXyA9IFwiRTpcXFxccWRcXFxcdnVlMy1hZG1pblxcXFxub2RlX21vZHVsZXNcXFxcaWdub3JlXFxcXGxlZ2FjeS5qc1wiO2NvbnN0IF9faW5qZWN0ZWRfZGlybmFtZV9fID0gXCJFOlxcXFxxZFxcXFx2dWUzLWFkbWluXFxcXG5vZGVfbW9kdWxlc1xcXFxpZ25vcmVcIjtjb25zdCBfX2luamVjdGVkX2ltcG9ydF9tZXRhX3VybF9fID0gXCJmaWxlOi8vL0U6L3FkL3Z1ZTMtYWRtaW4vbm9kZV9tb2R1bGVzL2lnbm9yZS9sZWdhY3kuanNcIjtcInVzZSBzdHJpY3RcIjtcblxuZnVuY3Rpb24gX3R5cGVvZihvYmopIHsgXCJAYmFiZWwvaGVscGVycyAtIHR5cGVvZlwiOyByZXR1cm4gX3R5cGVvZiA9IFwiZnVuY3Rpb25cIiA9PSB0eXBlb2YgU3ltYm9sICYmIFwic3ltYm9sXCIgPT0gdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA/IGZ1bmN0aW9uIChvYmopIHsgcmV0dXJuIHR5cGVvZiBvYmo7IH0gOiBmdW5jdGlvbiAob2JqKSB7IHJldHVybiBvYmogJiYgXCJmdW5jdGlvblwiID09IHR5cGVvZiBTeW1ib2wgJiYgb2JqLmNvbnN0cnVjdG9yID09PSBTeW1ib2wgJiYgb2JqICE9PSBTeW1ib2wucHJvdG90eXBlID8gXCJzeW1ib2xcIiA6IHR5cGVvZiBvYmo7IH0sIF90eXBlb2Yob2JqKTsgfVxuZnVuY3Rpb24gX2RlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykgeyBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7IHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07IGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTsgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlOyBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlOyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBfdG9Qcm9wZXJ0eUtleShkZXNjcmlwdG9yLmtleSksIGRlc2NyaXB0b3IpOyB9IH1cbmZ1bmN0aW9uIF9jcmVhdGVDbGFzcyhDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHsgaWYgKHByb3RvUHJvcHMpIF9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7IGlmIChzdGF0aWNQcm9wcykgX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KENvbnN0cnVjdG9yLCBcInByb3RvdHlwZVwiLCB7IHdyaXRhYmxlOiBmYWxzZSB9KTsgcmV0dXJuIENvbnN0cnVjdG9yOyB9XG5mdW5jdGlvbiBfdG9Qcm9wZXJ0eUtleShhcmcpIHsgdmFyIGtleSA9IF90b1ByaW1pdGl2ZShhcmcsIFwic3RyaW5nXCIpOyByZXR1cm4gX3R5cGVvZihrZXkpID09PSBcInN5bWJvbFwiID8ga2V5IDogU3RyaW5nKGtleSk7IH1cbmZ1bmN0aW9uIF90b1ByaW1pdGl2ZShpbnB1dCwgaGludCkgeyBpZiAoX3R5cGVvZihpbnB1dCkgIT09IFwib2JqZWN0XCIgfHwgaW5wdXQgPT09IG51bGwpIHJldHVybiBpbnB1dDsgdmFyIHByaW0gPSBpbnB1dFtTeW1ib2wudG9QcmltaXRpdmVdOyBpZiAocHJpbSAhPT0gdW5kZWZpbmVkKSB7IHZhciByZXMgPSBwcmltLmNhbGwoaW5wdXQsIGhpbnQgfHwgXCJkZWZhdWx0XCIpOyBpZiAoX3R5cGVvZihyZXMpICE9PSBcIm9iamVjdFwiKSByZXR1cm4gcmVzOyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQEB0b1ByaW1pdGl2ZSBtdXN0IHJldHVybiBhIHByaW1pdGl2ZSB2YWx1ZS5cIik7IH0gcmV0dXJuIChoaW50ID09PSBcInN0cmluZ1wiID8gU3RyaW5nIDogTnVtYmVyKShpbnB1dCk7IH1cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5mdW5jdGlvbiBfc2xpY2VkVG9BcnJheShhcnIsIGkpIHsgcmV0dXJuIF9hcnJheVdpdGhIb2xlcyhhcnIpIHx8IF9pdGVyYWJsZVRvQXJyYXlMaW1pdChhcnIsIGkpIHx8IF91bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheShhcnIsIGkpIHx8IF9ub25JdGVyYWJsZVJlc3QoKTsgfVxuZnVuY3Rpb24gX25vbkl0ZXJhYmxlUmVzdCgpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkludmFsaWQgYXR0ZW1wdCB0byBkZXN0cnVjdHVyZSBub24taXRlcmFibGUgaW5zdGFuY2UuXFxuSW4gb3JkZXIgdG8gYmUgaXRlcmFibGUsIG5vbi1hcnJheSBvYmplY3RzIG11c3QgaGF2ZSBhIFtTeW1ib2wuaXRlcmF0b3JdKCkgbWV0aG9kLlwiKTsgfVxuZnVuY3Rpb24gX3Vuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5KG8sIG1pbkxlbikgeyBpZiAoIW8pIHJldHVybjsgaWYgKHR5cGVvZiBvID09PSBcInN0cmluZ1wiKSByZXR1cm4gX2FycmF5TGlrZVRvQXJyYXkobywgbWluTGVuKTsgdmFyIG4gPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwobykuc2xpY2UoOCwgLTEpOyBpZiAobiA9PT0gXCJPYmplY3RcIiAmJiBvLmNvbnN0cnVjdG9yKSBuID0gby5jb25zdHJ1Y3Rvci5uYW1lOyBpZiAobiA9PT0gXCJNYXBcIiB8fCBuID09PSBcIlNldFwiKSByZXR1cm4gQXJyYXkuZnJvbShvKTsgaWYgKG4gPT09IFwiQXJndW1lbnRzXCIgfHwgL14oPzpVaXxJKW50KD86OHwxNnwzMikoPzpDbGFtcGVkKT9BcnJheSQvLnRlc3QobikpIHJldHVybiBfYXJyYXlMaWtlVG9BcnJheShvLCBtaW5MZW4pOyB9XG5mdW5jdGlvbiBfYXJyYXlMaWtlVG9BcnJheShhcnIsIGxlbikgeyBpZiAobGVuID09IG51bGwgfHwgbGVuID4gYXJyLmxlbmd0aCkgbGVuID0gYXJyLmxlbmd0aDsgZm9yICh2YXIgaSA9IDAsIGFycjIgPSBuZXcgQXJyYXkobGVuKTsgaSA8IGxlbjsgaSsrKSBhcnIyW2ldID0gYXJyW2ldOyByZXR1cm4gYXJyMjsgfVxuZnVuY3Rpb24gX2l0ZXJhYmxlVG9BcnJheUxpbWl0KGFyciwgaSkgeyB2YXIgX2kgPSBudWxsID09IGFyciA/IG51bGwgOiBcInVuZGVmaW5lZFwiICE9IHR5cGVvZiBTeW1ib2wgJiYgYXJyW1N5bWJvbC5pdGVyYXRvcl0gfHwgYXJyW1wiQEBpdGVyYXRvclwiXTsgaWYgKG51bGwgIT0gX2kpIHsgdmFyIF9zLCBfZSwgX3gsIF9yLCBfYXJyID0gW10sIF9uID0gITAsIF9kID0gITE7IHRyeSB7IGlmIChfeCA9IChfaSA9IF9pLmNhbGwoYXJyKSkubmV4dCwgMCA9PT0gaSkgeyBpZiAoT2JqZWN0KF9pKSAhPT0gX2kpIHJldHVybjsgX24gPSAhMTsgfSBlbHNlIGZvciAoOyAhKF9uID0gKF9zID0gX3guY2FsbChfaSkpLmRvbmUpICYmIChfYXJyLnB1c2goX3MudmFsdWUpLCBfYXJyLmxlbmd0aCAhPT0gaSk7IF9uID0gITApOyB9IGNhdGNoIChlcnIpIHsgX2QgPSAhMCwgX2UgPSBlcnI7IH0gZmluYWxseSB7IHRyeSB7IGlmICghX24gJiYgbnVsbCAhPSBfaVtcInJldHVyblwiXSAmJiAoX3IgPSBfaVtcInJldHVyblwiXSgpLCBPYmplY3QoX3IpICE9PSBfcikpIHJldHVybjsgfSBmaW5hbGx5IHsgaWYgKF9kKSB0aHJvdyBfZTsgfSB9IHJldHVybiBfYXJyOyB9IH1cbmZ1bmN0aW9uIF9hcnJheVdpdGhIb2xlcyhhcnIpIHsgaWYgKEFycmF5LmlzQXJyYXkoYXJyKSkgcmV0dXJuIGFycjsgfVxuLy8gQSBzaW1wbGUgaW1wbGVtZW50YXRpb24gb2YgbWFrZS1hcnJheVxuZnVuY3Rpb24gbWFrZUFycmF5KHN1YmplY3QpIHtcbiAgcmV0dXJuIEFycmF5LmlzQXJyYXkoc3ViamVjdCkgPyBzdWJqZWN0IDogW3N1YmplY3RdO1xufVxudmFyIEVNUFRZID0gJyc7XG52YXIgU1BBQ0UgPSAnICc7XG52YXIgRVNDQVBFID0gJ1xcXFwnO1xudmFyIFJFR0VYX1RFU1RfQkxBTktfTElORSA9IC9eXFxzKyQvO1xudmFyIFJFR0VYX0lOVkFMSURfVFJBSUxJTkdfQkFDS1NMQVNIID0gLyg/OlteXFxcXF18XilcXFxcJC87XG52YXIgUkVHRVhfUkVQTEFDRV9MRUFESU5HX0VYQ0FQRURfRVhDTEFNQVRJT04gPSAvXlxcXFwhLztcbnZhciBSRUdFWF9SRVBMQUNFX0xFQURJTkdfRVhDQVBFRF9IQVNIID0gL15cXFxcIy87XG52YXIgUkVHRVhfU1BMSVRBTExfQ1JMRiA9IC9cXHI/XFxuL2c7XG4vLyAvZm9vLFxuLy8gLi9mb28sXG4vLyAuLi9mb28sXG4vLyAuXG4vLyAuLlxudmFyIFJFR0VYX1RFU1RfSU5WQUxJRF9QQVRIID0gL15cXC4qXFwvfF5cXC4rJC87XG52YXIgU0xBU0ggPSAnLyc7XG5cbi8vIERvIG5vdCB1c2UgdGVybmFyeSBleHByZXNzaW9uIGhlcmUsIHNpbmNlIFwiaXN0YW5idWwgaWdub3JlIG5leHRcIiBpcyBidWdneVxudmFyIFRNUF9LRVlfSUdOT1JFID0gJ25vZGUtaWdub3JlJztcbi8qIGlzdGFuYnVsIGlnbm9yZSBlbHNlICovXG5pZiAodHlwZW9mIFN5bWJvbCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgVE1QX0tFWV9JR05PUkUgPSBTeW1ib2xbXCJmb3JcIl0oJ25vZGUtaWdub3JlJyk7XG59XG52YXIgS0VZX0lHTk9SRSA9IFRNUF9LRVlfSUdOT1JFO1xudmFyIGRlZmluZSA9IGZ1bmN0aW9uIGRlZmluZShvYmplY3QsIGtleSwgdmFsdWUpIHtcbiAgcmV0dXJuIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvYmplY3QsIGtleSwge1xuICAgIHZhbHVlOiB2YWx1ZVxuICB9KTtcbn07XG52YXIgUkVHRVhfUkVHRVhQX1JBTkdFID0gLyhbMC16XSktKFswLXpdKS9nO1xudmFyIFJFVFVSTl9GQUxTRSA9IGZ1bmN0aW9uIFJFVFVSTl9GQUxTRSgpIHtcbiAgcmV0dXJuIGZhbHNlO1xufTtcblxuLy8gU2FuaXRpemUgdGhlIHJhbmdlIG9mIGEgcmVndWxhciBleHByZXNzaW9uXG4vLyBUaGUgY2FzZXMgYXJlIGNvbXBsaWNhdGVkLCBzZWUgdGVzdCBjYXNlcyBmb3IgZGV0YWlsc1xudmFyIHNhbml0aXplUmFuZ2UgPSBmdW5jdGlvbiBzYW5pdGl6ZVJhbmdlKHJhbmdlKSB7XG4gIHJldHVybiByYW5nZS5yZXBsYWNlKFJFR0VYX1JFR0VYUF9SQU5HRSwgZnVuY3Rpb24gKG1hdGNoLCBmcm9tLCB0bykge1xuICAgIHJldHVybiBmcm9tLmNoYXJDb2RlQXQoMCkgPD0gdG8uY2hhckNvZGVBdCgwKSA/IG1hdGNoXG4gICAgLy8gSW52YWxpZCByYW5nZSAob3V0IG9mIG9yZGVyKSB3aGljaCBpcyBvayBmb3IgZ2l0aWdub3JlIHJ1bGVzIGJ1dFxuICAgIC8vICAgZmF0YWwgZm9yIEphdmFTY3JpcHQgcmVndWxhciBleHByZXNzaW9uLCBzbyBlbGltaW5hdGUgaXQuXG4gICAgOiBFTVBUWTtcbiAgfSk7XG59O1xuXG4vLyBTZWUgZml4dHVyZXMgIzU5XG52YXIgY2xlYW5SYW5nZUJhY2tTbGFzaCA9IGZ1bmN0aW9uIGNsZWFuUmFuZ2VCYWNrU2xhc2goc2xhc2hlcykge1xuICB2YXIgbGVuZ3RoID0gc2xhc2hlcy5sZW5ndGg7XG4gIHJldHVybiBzbGFzaGVzLnNsaWNlKDAsIGxlbmd0aCAtIGxlbmd0aCAlIDIpO1xufTtcblxuLy8gPiBJZiB0aGUgcGF0dGVybiBlbmRzIHdpdGggYSBzbGFzaCxcbi8vID4gaXQgaXMgcmVtb3ZlZCBmb3IgdGhlIHB1cnBvc2Ugb2YgdGhlIGZvbGxvd2luZyBkZXNjcmlwdGlvbixcbi8vID4gYnV0IGl0IHdvdWxkIG9ubHkgZmluZCBhIG1hdGNoIHdpdGggYSBkaXJlY3RvcnkuXG4vLyA+IEluIG90aGVyIHdvcmRzLCBmb28vIHdpbGwgbWF0Y2ggYSBkaXJlY3RvcnkgZm9vIGFuZCBwYXRocyB1bmRlcm5lYXRoIGl0LFxuLy8gPiBidXQgd2lsbCBub3QgbWF0Y2ggYSByZWd1bGFyIGZpbGUgb3IgYSBzeW1ib2xpYyBsaW5rIGZvb1xuLy8gPiAgKHRoaXMgaXMgY29uc2lzdGVudCB3aXRoIHRoZSB3YXkgaG93IHBhdGhzcGVjIHdvcmtzIGluIGdlbmVyYWwgaW4gR2l0KS5cbi8vICdgZm9vL2AnIHdpbGwgbm90IG1hdGNoIHJlZ3VsYXIgZmlsZSAnYGZvb2AnIG9yIHN5bWJvbGljIGxpbmsgJ2Bmb29gJ1xuLy8gLT4gaWdub3JlLXJ1bGVzIHdpbGwgbm90IGRlYWwgd2l0aCBpdCwgYmVjYXVzZSBpdCBjb3N0cyBleHRyYSBgZnMuc3RhdGAgY2FsbFxuLy8gICAgICB5b3UgY291bGQgdXNlIG9wdGlvbiBgbWFyazogdHJ1ZWAgd2l0aCBgZ2xvYmBcblxuLy8gJ2Bmb28vYCcgc2hvdWxkIG5vdCBjb250aW51ZSB3aXRoIHRoZSAnYC4uYCdcbnZhciBSRVBMQUNFUlMgPSBbW1xuLy8gcmVtb3ZlIEJPTVxuLy8gVE9ETzpcbi8vIE90aGVyIHNpbWlsYXIgemVyby13aWR0aCBjaGFyYWN0ZXJzP1xuL15cXHVGRUZGLywgZnVuY3Rpb24gKCkge1xuICByZXR1cm4gRU1QVFk7XG59XSxcbi8vID4gVHJhaWxpbmcgc3BhY2VzIGFyZSBpZ25vcmVkIHVubGVzcyB0aGV5IGFyZSBxdW90ZWQgd2l0aCBiYWNrc2xhc2ggKFwiXFxcIilcbltcbi8vIChhXFwgKSAtPiAoYSApXG4vLyAoYSAgKSAtPiAoYSlcbi8vIChhICkgLT4gKGEpXG4vLyAoYSBcXCApIC0+IChhICApXG4vKCg/OlxcXFxcXFxcKSo/KShcXFxcP1xccyspJC8sIGZ1bmN0aW9uIChfLCBtMSwgbTIpIHtcbiAgcmV0dXJuIG0xICsgKG0yLmluZGV4T2YoJ1xcXFwnKSA9PT0gMCA/IFNQQUNFIDogRU1QVFkpO1xufV0sXG4vLyByZXBsYWNlIChcXCApIHdpdGggJyAnXG4vLyAoXFwgKSAtPiAnICdcbi8vIChcXFxcICkgLT4gJ1xcXFwgJ1xuLy8gKFxcXFxcXCApIC0+ICdcXFxcICdcblsvKFxcXFwrPylcXHMvZywgZnVuY3Rpb24gKF8sIG0xKSB7XG4gIHZhciBsZW5ndGggPSBtMS5sZW5ndGg7XG4gIHJldHVybiBtMS5zbGljZSgwLCBsZW5ndGggLSBsZW5ndGggJSAyKSArIFNQQUNFO1xufV0sXG4vLyBFc2NhcGUgbWV0YWNoYXJhY3RlcnNcbi8vIHdoaWNoIGlzIHdyaXR0ZW4gZG93biBieSB1c2VycyBidXQgbWVhbnMgc3BlY2lhbCBmb3IgcmVndWxhciBleHByZXNzaW9ucy5cblxuLy8gPiBUaGVyZSBhcmUgMTIgY2hhcmFjdGVycyB3aXRoIHNwZWNpYWwgbWVhbmluZ3M6XG4vLyA+IC0gdGhlIGJhY2tzbGFzaCBcXCxcbi8vID4gLSB0aGUgY2FyZXQgXixcbi8vID4gLSB0aGUgZG9sbGFyIHNpZ24gJCxcbi8vID4gLSB0aGUgcGVyaW9kIG9yIGRvdCAuLFxuLy8gPiAtIHRoZSB2ZXJ0aWNhbCBiYXIgb3IgcGlwZSBzeW1ib2wgfCxcbi8vID4gLSB0aGUgcXVlc3Rpb24gbWFyayA/LFxuLy8gPiAtIHRoZSBhc3RlcmlzayBvciBzdGFyICosXG4vLyA+IC0gdGhlIHBsdXMgc2lnbiArLFxuLy8gPiAtIHRoZSBvcGVuaW5nIHBhcmVudGhlc2lzICgsXG4vLyA+IC0gdGhlIGNsb3NpbmcgcGFyZW50aGVzaXMgKSxcbi8vID4gLSBhbmQgdGhlIG9wZW5pbmcgc3F1YXJlIGJyYWNrZXQgWyxcbi8vID4gLSB0aGUgb3BlbmluZyBjdXJseSBicmFjZSB7LFxuLy8gPiBUaGVzZSBzcGVjaWFsIGNoYXJhY3RlcnMgYXJlIG9mdGVuIGNhbGxlZCBcIm1ldGFjaGFyYWN0ZXJzXCIuXG5bL1tcXFxcJC58KisoKXteXS9nLCBmdW5jdGlvbiAobWF0Y2gpIHtcbiAgcmV0dXJuIFwiXFxcXFwiLmNvbmNhdChtYXRjaCk7XG59XSwgW1xuLy8gPiBhIHF1ZXN0aW9uIG1hcmsgKD8pIG1hdGNoZXMgYSBzaW5nbGUgY2hhcmFjdGVyXG4vKD8hXFxcXClcXD8vZywgZnVuY3Rpb24gKCkge1xuICByZXR1cm4gJ1teL10nO1xufV0sXG4vLyBsZWFkaW5nIHNsYXNoXG5bXG4vLyA+IEEgbGVhZGluZyBzbGFzaCBtYXRjaGVzIHRoZSBiZWdpbm5pbmcgb2YgdGhlIHBhdGhuYW1lLlxuLy8gPiBGb3IgZXhhbXBsZSwgXCIvKi5jXCIgbWF0Y2hlcyBcImNhdC1maWxlLmNcIiBidXQgbm90IFwibW96aWxsYS1zaGExL3NoYTEuY1wiLlxuLy8gQSBsZWFkaW5nIHNsYXNoIG1hdGNoZXMgdGhlIGJlZ2lubmluZyBvZiB0aGUgcGF0aG5hbWVcbi9eXFwvLywgZnVuY3Rpb24gKCkge1xuICByZXR1cm4gJ14nO1xufV0sXG4vLyByZXBsYWNlIHNwZWNpYWwgbWV0YWNoYXJhY3RlciBzbGFzaCBhZnRlciB0aGUgbGVhZGluZyBzbGFzaFxuWy9cXC8vZywgZnVuY3Rpb24gKCkge1xuICByZXR1cm4gJ1xcXFwvJztcbn1dLCBbXG4vLyA+IEEgbGVhZGluZyBcIioqXCIgZm9sbG93ZWQgYnkgYSBzbGFzaCBtZWFucyBtYXRjaCBpbiBhbGwgZGlyZWN0b3JpZXMuXG4vLyA+IEZvciBleGFtcGxlLCBcIioqL2Zvb1wiIG1hdGNoZXMgZmlsZSBvciBkaXJlY3RvcnkgXCJmb29cIiBhbnl3aGVyZSxcbi8vID4gdGhlIHNhbWUgYXMgcGF0dGVybiBcImZvb1wiLlxuLy8gPiBcIioqL2Zvby9iYXJcIiBtYXRjaGVzIGZpbGUgb3IgZGlyZWN0b3J5IFwiYmFyXCIgYW55d2hlcmUgdGhhdCBpcyBkaXJlY3RseVxuLy8gPiAgIHVuZGVyIGRpcmVjdG9yeSBcImZvb1wiLlxuLy8gTm90aWNlIHRoYXQgdGhlICcqJ3MgaGF2ZSBiZWVuIHJlcGxhY2VkIGFzICdcXFxcKidcbi9eXFxeKlxcXFxcXCpcXFxcXFwqXFxcXFxcLy8sXG4vLyAnKiovZm9vJyA8LT4gJ2ZvbydcbmZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuICdeKD86LipcXFxcLyk/Jztcbn1dLFxuLy8gc3RhcnRpbmdcbltcbi8vIHRoZXJlIHdpbGwgYmUgbm8gbGVhZGluZyAnLydcbi8vICAgKHdoaWNoIGhhcyBiZWVuIHJlcGxhY2VkIGJ5IHNlY3Rpb24gXCJsZWFkaW5nIHNsYXNoXCIpXG4vLyBJZiBzdGFydHMgd2l0aCAnKionLCBhZGRpbmcgYSAnXicgdG8gdGhlIHJlZ3VsYXIgZXhwcmVzc2lvbiBhbHNvIHdvcmtzXG4vXig/PVteXl0pLywgZnVuY3Rpb24gc3RhcnRpbmdSZXBsYWNlcigpIHtcbiAgLy8gSWYgaGFzIGEgc2xhc2ggYC9gIGF0IHRoZSBiZWdpbm5pbmcgb3IgbWlkZGxlXG4gIHJldHVybiAhL1xcLyg/ISQpLy50ZXN0KHRoaXMpXG4gIC8vID4gUHJpb3IgdG8gMi4yMi4xXG4gIC8vID4gSWYgdGhlIHBhdHRlcm4gZG9lcyBub3QgY29udGFpbiBhIHNsYXNoIC8sXG4gIC8vID4gICBHaXQgdHJlYXRzIGl0IGFzIGEgc2hlbGwgZ2xvYiBwYXR0ZXJuXG4gIC8vIEFjdHVhbGx5LCBpZiB0aGVyZSBpcyBvbmx5IGEgdHJhaWxpbmcgc2xhc2gsXG4gIC8vICAgZ2l0IGFsc28gdHJlYXRzIGl0IGFzIGEgc2hlbGwgZ2xvYiBwYXR0ZXJuXG5cbiAgLy8gQWZ0ZXIgMi4yMi4xIChjb21wYXRpYmxlIGJ1dCBjbGVhcmVyKVxuICAvLyA+IElmIHRoZXJlIGlzIGEgc2VwYXJhdG9yIGF0IHRoZSBiZWdpbm5pbmcgb3IgbWlkZGxlIChvciBib3RoKVxuICAvLyA+IG9mIHRoZSBwYXR0ZXJuLCB0aGVuIHRoZSBwYXR0ZXJuIGlzIHJlbGF0aXZlIHRvIHRoZSBkaXJlY3RvcnlcbiAgLy8gPiBsZXZlbCBvZiB0aGUgcGFydGljdWxhciAuZ2l0aWdub3JlIGZpbGUgaXRzZWxmLlxuICAvLyA+IE90aGVyd2lzZSB0aGUgcGF0dGVybiBtYXkgYWxzbyBtYXRjaCBhdCBhbnkgbGV2ZWwgYmVsb3dcbiAgLy8gPiB0aGUgLmdpdGlnbm9yZSBsZXZlbC5cbiAgPyAnKD86XnxcXFxcLyknXG5cbiAgLy8gPiBPdGhlcndpc2UsIEdpdCB0cmVhdHMgdGhlIHBhdHRlcm4gYXMgYSBzaGVsbCBnbG9iIHN1aXRhYmxlIGZvclxuICAvLyA+ICAgY29uc3VtcHRpb24gYnkgZm5tYXRjaCgzKVxuICA6ICdeJztcbn1dLFxuLy8gdHdvIGdsb2JzdGFyc1xuW1xuLy8gVXNlIGxvb2thaGVhZCBhc3NlcnRpb25zIHNvIHRoYXQgd2UgY291bGQgbWF0Y2ggbW9yZSB0aGFuIG9uZSBgJy8qKidgXG4vXFxcXFxcL1xcXFxcXCpcXFxcXFwqKD89XFxcXFxcL3wkKS9nLFxuLy8gWmVybywgb25lIG9yIHNldmVyYWwgZGlyZWN0b3JpZXNcbi8vIHNob3VsZCBub3QgdXNlICcqJywgb3IgaXQgd2lsbCBiZSByZXBsYWNlZCBieSB0aGUgbmV4dCByZXBsYWNlclxuXG4vLyBDaGVjayBpZiBpdCBpcyBub3QgdGhlIGxhc3QgYCcvKionYFxuZnVuY3Rpb24gKF8sIGluZGV4LCBzdHIpIHtcbiAgcmV0dXJuIGluZGV4ICsgNiA8IHN0ci5sZW5ndGhcblxuICAvLyBjYXNlOiAvKiovXG4gIC8vID4gQSBzbGFzaCBmb2xsb3dlZCBieSB0d28gY29uc2VjdXRpdmUgYXN0ZXJpc2tzIHRoZW4gYSBzbGFzaCBtYXRjaGVzXG4gIC8vID4gICB6ZXJvIG9yIG1vcmUgZGlyZWN0b3JpZXMuXG4gIC8vID4gRm9yIGV4YW1wbGUsIFwiYS8qKi9iXCIgbWF0Y2hlcyBcImEvYlwiLCBcImEveC9iXCIsIFwiYS94L3kvYlwiIGFuZCBzbyBvbi5cbiAgLy8gJy8qKi8nXG4gID8gJyg/OlxcXFwvW15cXFxcL10rKSonXG5cbiAgLy8gY2FzZTogLyoqXG4gIC8vID4gQSB0cmFpbGluZyBgXCIvKipcImAgbWF0Y2hlcyBldmVyeXRoaW5nIGluc2lkZS5cblxuICAvLyAjMjE6IGV2ZXJ5dGhpbmcgaW5zaWRlIGJ1dCBpdCBzaG91bGQgbm90IGluY2x1ZGUgdGhlIGN1cnJlbnQgZm9sZGVyXG4gIDogJ1xcXFwvLisnO1xufV0sXG4vLyBub3JtYWwgaW50ZXJtZWRpYXRlIHdpbGRjYXJkc1xuW1xuLy8gTmV2ZXIgcmVwbGFjZSBlc2NhcGVkICcqJ1xuLy8gaWdub3JlIHJ1bGUgJ1xcKicgd2lsbCBtYXRjaCB0aGUgcGF0aCAnKidcblxuLy8gJ2FiYy4qLycgLT4gZ29cbi8vICdhYmMuKicgIC0+IHNraXAgdGhpcyBydWxlLFxuLy8gICAgY296IHRyYWlsaW5nIHNpbmdsZSB3aWxkY2FyZCB3aWxsIGJlIGhhbmRlZCBieSBbdHJhaWxpbmcgd2lsZGNhcmRdXG4vKF58W15cXFxcXSspKFxcXFxcXCopKyg/PS4rKS9nLFxuLy8gJyouanMnIG1hdGNoZXMgJy5qcydcbi8vICcqLmpzJyBkb2Vzbid0IG1hdGNoICdhYmMnXG5mdW5jdGlvbiAoXywgcDEsIHAyKSB7XG4gIC8vIDEuXG4gIC8vID4gQW4gYXN0ZXJpc2sgXCIqXCIgbWF0Y2hlcyBhbnl0aGluZyBleGNlcHQgYSBzbGFzaC5cbiAgLy8gMi5cbiAgLy8gPiBPdGhlciBjb25zZWN1dGl2ZSBhc3Rlcmlza3MgYXJlIGNvbnNpZGVyZWQgcmVndWxhciBhc3Rlcmlza3NcbiAgLy8gPiBhbmQgd2lsbCBtYXRjaCBhY2NvcmRpbmcgdG8gdGhlIHByZXZpb3VzIHJ1bGVzLlxuICB2YXIgdW5lc2NhcGVkID0gcDIucmVwbGFjZSgvXFxcXFxcKi9nLCAnW15cXFxcL10qJyk7XG4gIHJldHVybiBwMSArIHVuZXNjYXBlZDtcbn1dLCBbXG4vLyB1bmVzY2FwZSwgcmV2ZXJ0IHN0ZXAgMyBleGNlcHQgZm9yIGJhY2sgc2xhc2hcbi8vIEZvciBleGFtcGxlLCBpZiBhIHVzZXIgZXNjYXBlIGEgJ1xcXFwqJyxcbi8vIGFmdGVyIHN0ZXAgMywgdGhlIHJlc3VsdCB3aWxsIGJlICdcXFxcXFxcXFxcXFwqJ1xuL1xcXFxcXFxcXFxcXCg/PVskLnwqKygpe15dKS9nLCBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiBFU0NBUEU7XG59XSwgW1xuLy8gJ1xcXFxcXFxcJyAtPiAnXFxcXCdcbi9cXFxcXFxcXC9nLCBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiBFU0NBUEU7XG59XSwgW1xuLy8gPiBUaGUgcmFuZ2Ugbm90YXRpb24sIGUuZy4gW2EtekEtWl0sXG4vLyA+IGNhbiBiZSB1c2VkIHRvIG1hdGNoIG9uZSBvZiB0aGUgY2hhcmFjdGVycyBpbiBhIHJhbmdlLlxuXG4vLyBgXFxgIGlzIGVzY2FwZWQgYnkgc3RlcCAzXG4vKFxcXFwpP1xcWyhbXlxcXS9dKj8pKFxcXFwqKSgkfFxcXSkvZywgZnVuY3Rpb24gKG1hdGNoLCBsZWFkRXNjYXBlLCByYW5nZSwgZW5kRXNjYXBlLCBjbG9zZSkge1xuICByZXR1cm4gbGVhZEVzY2FwZSA9PT0gRVNDQVBFXG4gIC8vICdcXFxcW2Jhcl0nIC0+ICdcXFxcXFxcXFtiYXJcXFxcXSdcbiAgPyBcIlxcXFxbXCIuY29uY2F0KHJhbmdlKS5jb25jYXQoY2xlYW5SYW5nZUJhY2tTbGFzaChlbmRFc2NhcGUpKS5jb25jYXQoY2xvc2UpIDogY2xvc2UgPT09ICddJyA/IGVuZEVzY2FwZS5sZW5ndGggJSAyID09PSAwXG4gIC8vIEEgbm9ybWFsIGNhc2UsIGFuZCBpdCBpcyBhIHJhbmdlIG5vdGF0aW9uXG4gIC8vICdbYmFyXSdcbiAgLy8gJ1tiYXJcXFxcXFxcXF0nXG4gID8gXCJbXCIuY29uY2F0KHNhbml0aXplUmFuZ2UocmFuZ2UpKS5jb25jYXQoZW5kRXNjYXBlLCBcIl1cIikgLy8gSW52YWxpZCByYW5nZSBub3RhdG9uXG4gIC8vICdbYmFyXFxcXF0nIC0+ICdbYmFyXFxcXFxcXFxdJ1xuICA6ICdbXScgOiAnW10nO1xufV0sXG4vLyBlbmRpbmdcbltcbi8vICdqcycgd2lsbCBub3QgbWF0Y2ggJ2pzLidcbi8vICdhYicgd2lsbCBub3QgbWF0Y2ggJ2FiYydcbi8oPzpbXipdKSQvLFxuLy8gV1RGIVxuLy8gaHR0cHM6Ly9naXQtc2NtLmNvbS9kb2NzL2dpdGlnbm9yZVxuLy8gY2hhbmdlcyBpbiBbMi4yMi4xXShodHRwczovL2dpdC1zY20uY29tL2RvY3MvZ2l0aWdub3JlLzIuMjIuMSlcbi8vIHdoaWNoIHJlLWZpeGVzICMyNCwgIzM4XG5cbi8vID4gSWYgdGhlcmUgaXMgYSBzZXBhcmF0b3IgYXQgdGhlIGVuZCBvZiB0aGUgcGF0dGVybiB0aGVuIHRoZSBwYXR0ZXJuXG4vLyA+IHdpbGwgb25seSBtYXRjaCBkaXJlY3Rvcmllcywgb3RoZXJ3aXNlIHRoZSBwYXR0ZXJuIGNhbiBtYXRjaCBib3RoXG4vLyA+IGZpbGVzIGFuZCBkaXJlY3Rvcmllcy5cblxuLy8gJ2pzKicgd2lsbCBub3QgbWF0Y2ggJ2EuanMnXG4vLyAnanMvJyB3aWxsIG5vdCBtYXRjaCAnYS5qcydcbi8vICdqcycgd2lsbCBtYXRjaCAnYS5qcycgYW5kICdhLmpzLydcbmZ1bmN0aW9uIChtYXRjaCkge1xuICByZXR1cm4gL1xcLyQvLnRlc3QobWF0Y2gpXG4gIC8vIGZvby8gd2lsbCBub3QgbWF0Y2ggJ2ZvbydcbiAgPyBcIlwiLmNvbmNhdChtYXRjaCwgXCIkXCIpIC8vIGZvbyBtYXRjaGVzICdmb28nIGFuZCAnZm9vLydcbiAgOiBcIlwiLmNvbmNhdChtYXRjaCwgXCIoPz0kfFxcXFwvJClcIik7XG59XSxcbi8vIHRyYWlsaW5nIHdpbGRjYXJkXG5bLyhcXF58XFxcXFxcLyk/XFxcXFxcKiQvLCBmdW5jdGlvbiAoXywgcDEpIHtcbiAgdmFyIHByZWZpeCA9IHAxXG4gIC8vICdcXF4nOlxuICAvLyAnLyonIGRvZXMgbm90IG1hdGNoIEVNUFRZXG4gIC8vICcvKicgZG9lcyBub3QgbWF0Y2ggZXZlcnl0aGluZ1xuXG4gIC8vICdcXFxcXFwvJzpcbiAgLy8gJ2FiYy8qJyBkb2VzIG5vdCBtYXRjaCAnYWJjLydcbiAgPyBcIlwiLmNvbmNhdChwMSwgXCJbXi9dK1wiKSAvLyAnYSonIG1hdGNoZXMgJ2EnXG4gIC8vICdhKicgbWF0Y2hlcyAnYWEnXG4gIDogJ1teL10qJztcbiAgcmV0dXJuIFwiXCIuY29uY2F0KHByZWZpeCwgXCIoPz0kfFxcXFwvJClcIik7XG59XV07XG5cbi8vIEEgc2ltcGxlIGNhY2hlLCBiZWNhdXNlIGFuIGlnbm9yZSBydWxlIG9ubHkgaGFzIG9ubHkgb25lIGNlcnRhaW4gbWVhbmluZ1xudmFyIHJlZ2V4Q2FjaGUgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuXG4vLyBAcGFyYW0ge3BhdHRlcm59XG52YXIgbWFrZVJlZ2V4ID0gZnVuY3Rpb24gbWFrZVJlZ2V4KHBhdHRlcm4sIGlnbm9yZUNhc2UpIHtcbiAgdmFyIHNvdXJjZSA9IHJlZ2V4Q2FjaGVbcGF0dGVybl07XG4gIGlmICghc291cmNlKSB7XG4gICAgc291cmNlID0gUkVQTEFDRVJTLnJlZHVjZShmdW5jdGlvbiAocHJldiwgX3JlZikge1xuICAgICAgdmFyIF9yZWYyID0gX3NsaWNlZFRvQXJyYXkoX3JlZiwgMiksXG4gICAgICAgIG1hdGNoZXIgPSBfcmVmMlswXSxcbiAgICAgICAgcmVwbGFjZXIgPSBfcmVmMlsxXTtcbiAgICAgIHJldHVybiBwcmV2LnJlcGxhY2UobWF0Y2hlciwgcmVwbGFjZXIuYmluZChwYXR0ZXJuKSk7XG4gICAgfSwgcGF0dGVybik7XG4gICAgcmVnZXhDYWNoZVtwYXR0ZXJuXSA9IHNvdXJjZTtcbiAgfVxuICByZXR1cm4gaWdub3JlQ2FzZSA/IG5ldyBSZWdFeHAoc291cmNlLCAnaScpIDogbmV3IFJlZ0V4cChzb3VyY2UpO1xufTtcbnZhciBpc1N0cmluZyA9IGZ1bmN0aW9uIGlzU3RyaW5nKHN1YmplY3QpIHtcbiAgcmV0dXJuIHR5cGVvZiBzdWJqZWN0ID09PSAnc3RyaW5nJztcbn07XG5cbi8vID4gQSBibGFuayBsaW5lIG1hdGNoZXMgbm8gZmlsZXMsIHNvIGl0IGNhbiBzZXJ2ZSBhcyBhIHNlcGFyYXRvciBmb3IgcmVhZGFiaWxpdHkuXG52YXIgY2hlY2tQYXR0ZXJuID0gZnVuY3Rpb24gY2hlY2tQYXR0ZXJuKHBhdHRlcm4pIHtcbiAgcmV0dXJuIHBhdHRlcm4gJiYgaXNTdHJpbmcocGF0dGVybikgJiYgIVJFR0VYX1RFU1RfQkxBTktfTElORS50ZXN0KHBhdHRlcm4pICYmICFSRUdFWF9JTlZBTElEX1RSQUlMSU5HX0JBQ0tTTEFTSC50ZXN0KHBhdHRlcm4pXG5cbiAgLy8gPiBBIGxpbmUgc3RhcnRpbmcgd2l0aCAjIHNlcnZlcyBhcyBhIGNvbW1lbnQuXG4gICYmIHBhdHRlcm4uaW5kZXhPZignIycpICE9PSAwO1xufTtcbnZhciBzcGxpdFBhdHRlcm4gPSBmdW5jdGlvbiBzcGxpdFBhdHRlcm4ocGF0dGVybikge1xuICByZXR1cm4gcGF0dGVybi5zcGxpdChSRUdFWF9TUExJVEFMTF9DUkxGKTtcbn07XG52YXIgSWdub3JlUnVsZSA9IC8qI19fUFVSRV9fKi9fY3JlYXRlQ2xhc3MoZnVuY3Rpb24gSWdub3JlUnVsZShvcmlnaW4sIHBhdHRlcm4sIG5lZ2F0aXZlLCByZWdleCkge1xuICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgSWdub3JlUnVsZSk7XG4gIHRoaXMub3JpZ2luID0gb3JpZ2luO1xuICB0aGlzLnBhdHRlcm4gPSBwYXR0ZXJuO1xuICB0aGlzLm5lZ2F0aXZlID0gbmVnYXRpdmU7XG4gIHRoaXMucmVnZXggPSByZWdleDtcbn0pO1xudmFyIGNyZWF0ZVJ1bGUgPSBmdW5jdGlvbiBjcmVhdGVSdWxlKHBhdHRlcm4sIGlnbm9yZUNhc2UpIHtcbiAgdmFyIG9yaWdpbiA9IHBhdHRlcm47XG4gIHZhciBuZWdhdGl2ZSA9IGZhbHNlO1xuXG4gIC8vID4gQW4gb3B0aW9uYWwgcHJlZml4IFwiIVwiIHdoaWNoIG5lZ2F0ZXMgdGhlIHBhdHRlcm47XG4gIGlmIChwYXR0ZXJuLmluZGV4T2YoJyEnKSA9PT0gMCkge1xuICAgIG5lZ2F0aXZlID0gdHJ1ZTtcbiAgICBwYXR0ZXJuID0gcGF0dGVybi5zdWJzdHIoMSk7XG4gIH1cbiAgcGF0dGVybiA9IHBhdHRlcm5cbiAgLy8gPiBQdXQgYSBiYWNrc2xhc2ggKFwiXFxcIikgaW4gZnJvbnQgb2YgdGhlIGZpcnN0IFwiIVwiIGZvciBwYXR0ZXJucyB0aGF0XG4gIC8vID4gICBiZWdpbiB3aXRoIGEgbGl0ZXJhbCBcIiFcIiwgZm9yIGV4YW1wbGUsIGBcIlxcIWltcG9ydGFudCEudHh0XCJgLlxuICAucmVwbGFjZShSRUdFWF9SRVBMQUNFX0xFQURJTkdfRVhDQVBFRF9FWENMQU1BVElPTiwgJyEnKVxuICAvLyA+IFB1dCBhIGJhY2tzbGFzaCAoXCJcXFwiKSBpbiBmcm9udCBvZiB0aGUgZmlyc3QgaGFzaCBmb3IgcGF0dGVybnMgdGhhdFxuICAvLyA+ICAgYmVnaW4gd2l0aCBhIGhhc2guXG4gIC5yZXBsYWNlKFJFR0VYX1JFUExBQ0VfTEVBRElOR19FWENBUEVEX0hBU0gsICcjJyk7XG4gIHZhciByZWdleCA9IG1ha2VSZWdleChwYXR0ZXJuLCBpZ25vcmVDYXNlKTtcbiAgcmV0dXJuIG5ldyBJZ25vcmVSdWxlKG9yaWdpbiwgcGF0dGVybiwgbmVnYXRpdmUsIHJlZ2V4KTtcbn07XG52YXIgdGhyb3dFcnJvciA9IGZ1bmN0aW9uIHRocm93RXJyb3IobWVzc2FnZSwgQ3Rvcikge1xuICB0aHJvdyBuZXcgQ3RvcihtZXNzYWdlKTtcbn07XG52YXIgY2hlY2tQYXRoID0gZnVuY3Rpb24gY2hlY2tQYXRoKHBhdGgsIG9yaWdpbmFsUGF0aCwgZG9UaHJvdykge1xuICBpZiAoIWlzU3RyaW5nKHBhdGgpKSB7XG4gICAgcmV0dXJuIGRvVGhyb3coXCJwYXRoIG11c3QgYmUgYSBzdHJpbmcsIGJ1dCBnb3QgYFwiLmNvbmNhdChvcmlnaW5hbFBhdGgsIFwiYFwiKSwgVHlwZUVycm9yKTtcbiAgfVxuXG4gIC8vIFdlIGRvbid0IGtub3cgaWYgd2Ugc2hvdWxkIGlnbm9yZSBFTVBUWSwgc28gdGhyb3dcbiAgaWYgKCFwYXRoKSB7XG4gICAgcmV0dXJuIGRvVGhyb3coXCJwYXRoIG11c3Qgbm90IGJlIGVtcHR5XCIsIFR5cGVFcnJvcik7XG4gIH1cblxuICAvLyBDaGVjayBpZiBpdCBpcyBhIHJlbGF0aXZlIHBhdGhcbiAgaWYgKGNoZWNrUGF0aC5pc05vdFJlbGF0aXZlKHBhdGgpKSB7XG4gICAgdmFyIHIgPSAnYHBhdGgucmVsYXRpdmUoKWBkJztcbiAgICByZXR1cm4gZG9UaHJvdyhcInBhdGggc2hvdWxkIGJlIGEgXCIuY29uY2F0KHIsIFwiIHN0cmluZywgYnV0IGdvdCBcXFwiXCIpLmNvbmNhdChvcmlnaW5hbFBhdGgsIFwiXFxcIlwiKSwgUmFuZ2VFcnJvcik7XG4gIH1cbiAgcmV0dXJuIHRydWU7XG59O1xudmFyIGlzTm90UmVsYXRpdmUgPSBmdW5jdGlvbiBpc05vdFJlbGF0aXZlKHBhdGgpIHtcbiAgcmV0dXJuIFJFR0VYX1RFU1RfSU5WQUxJRF9QQVRILnRlc3QocGF0aCk7XG59O1xuY2hlY2tQYXRoLmlzTm90UmVsYXRpdmUgPSBpc05vdFJlbGF0aXZlO1xuY2hlY2tQYXRoLmNvbnZlcnQgPSBmdW5jdGlvbiAocCkge1xuICByZXR1cm4gcDtcbn07XG52YXIgSWdub3JlID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gSWdub3JlKCkge1xuICAgIHZhciBfcmVmMyA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDoge30sXG4gICAgICBfcmVmMyRpZ25vcmVjYXNlID0gX3JlZjMuaWdub3JlY2FzZSxcbiAgICAgIGlnbm9yZWNhc2UgPSBfcmVmMyRpZ25vcmVjYXNlID09PSB2b2lkIDAgPyB0cnVlIDogX3JlZjMkaWdub3JlY2FzZSxcbiAgICAgIF9yZWYzJGlnbm9yZUNhc2UgPSBfcmVmMy5pZ25vcmVDYXNlLFxuICAgICAgaWdub3JlQ2FzZSA9IF9yZWYzJGlnbm9yZUNhc2UgPT09IHZvaWQgMCA/IGlnbm9yZWNhc2UgOiBfcmVmMyRpZ25vcmVDYXNlLFxuICAgICAgX3JlZjMkYWxsb3dSZWxhdGl2ZVBhID0gX3JlZjMuYWxsb3dSZWxhdGl2ZVBhdGhzLFxuICAgICAgYWxsb3dSZWxhdGl2ZVBhdGhzID0gX3JlZjMkYWxsb3dSZWxhdGl2ZVBhID09PSB2b2lkIDAgPyBmYWxzZSA6IF9yZWYzJGFsbG93UmVsYXRpdmVQYTtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgSWdub3JlKTtcbiAgICBkZWZpbmUodGhpcywgS0VZX0lHTk9SRSwgdHJ1ZSk7XG4gICAgdGhpcy5fcnVsZXMgPSBbXTtcbiAgICB0aGlzLl9pZ25vcmVDYXNlID0gaWdub3JlQ2FzZTtcbiAgICB0aGlzLl9hbGxvd1JlbGF0aXZlUGF0aHMgPSBhbGxvd1JlbGF0aXZlUGF0aHM7XG4gICAgdGhpcy5faW5pdENhY2hlKCk7XG4gIH1cbiAgX2NyZWF0ZUNsYXNzKElnbm9yZSwgW3tcbiAgICBrZXk6IFwiX2luaXRDYWNoZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfaW5pdENhY2hlKCkge1xuICAgICAgdGhpcy5faWdub3JlQ2FjaGUgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgICAgdGhpcy5fdGVzdENhY2hlID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiX2FkZFBhdHRlcm5cIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2FkZFBhdHRlcm4ocGF0dGVybikge1xuICAgICAgLy8gIzMyXG4gICAgICBpZiAocGF0dGVybiAmJiBwYXR0ZXJuW0tFWV9JR05PUkVdKSB7XG4gICAgICAgIHRoaXMuX3J1bGVzID0gdGhpcy5fcnVsZXMuY29uY2F0KHBhdHRlcm4uX3J1bGVzKTtcbiAgICAgICAgdGhpcy5fYWRkZWQgPSB0cnVlO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBpZiAoY2hlY2tQYXR0ZXJuKHBhdHRlcm4pKSB7XG4gICAgICAgIHZhciBydWxlID0gY3JlYXRlUnVsZShwYXR0ZXJuLCB0aGlzLl9pZ25vcmVDYXNlKTtcbiAgICAgICAgdGhpcy5fYWRkZWQgPSB0cnVlO1xuICAgICAgICB0aGlzLl9ydWxlcy5wdXNoKHJ1bGUpO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIEBwYXJhbSB7QXJyYXk8c3RyaW5nPiB8IHN0cmluZyB8IElnbm9yZX0gcGF0dGVyblxuICB9LCB7XG4gICAga2V5OiBcImFkZFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBhZGQocGF0dGVybikge1xuICAgICAgdGhpcy5fYWRkZWQgPSBmYWxzZTtcbiAgICAgIG1ha2VBcnJheShpc1N0cmluZyhwYXR0ZXJuKSA/IHNwbGl0UGF0dGVybihwYXR0ZXJuKSA6IHBhdHRlcm4pLmZvckVhY2godGhpcy5fYWRkUGF0dGVybiwgdGhpcyk7XG5cbiAgICAgIC8vIFNvbWUgcnVsZXMgaGF2ZSBqdXN0IGFkZGVkIHRvIHRoZSBpZ25vcmUsXG4gICAgICAvLyBtYWtpbmcgdGhlIGJlaGF2aW9yIGNoYW5nZWQuXG4gICAgICBpZiAodGhpcy5fYWRkZWQpIHtcbiAgICAgICAgdGhpcy5faW5pdENhY2hlKCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICAvLyBsZWdhY3lcbiAgfSwge1xuICAgIGtleTogXCJhZGRQYXR0ZXJuXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGFkZFBhdHRlcm4ocGF0dGVybikge1xuICAgICAgcmV0dXJuIHRoaXMuYWRkKHBhdHRlcm4pO1xuICAgIH1cblxuICAgIC8vICAgICAgICAgIHwgICAgICAgICAgIGlnbm9yZWQgOiB1bmlnbm9yZWRcbiAgICAvLyBuZWdhdGl2ZSB8ICAgMDowICAgfCAgIDA6MSAgIHwgICAxOjAgICB8ICAgMToxXG4gICAgLy8gLS0tLS0tLS0gfCAtLS0tLS0tIHwgLS0tLS0tLSB8IC0tLS0tLS0gfCAtLS0tLS0tLVxuICAgIC8vICAgICAwICAgIHwgIFRFU1QgICB8ICBURVNUICAgfCAgU0tJUCAgIHwgICAgWFxuICAgIC8vICAgICAxICAgIHwgIFRFU1RJRiB8ICBTS0lQICAgfCAgVEVTVCAgIHwgICAgWFxuXG4gICAgLy8gLSBTS0lQOiBhbHdheXMgc2tpcFxuICAgIC8vIC0gVEVTVDogYWx3YXlzIHRlc3RcbiAgICAvLyAtIFRFU1RJRjogb25seSB0ZXN0IGlmIGNoZWNrVW5pZ25vcmVkXG4gICAgLy8gLSBYOiB0aGF0IG5ldmVyIGhhcHBlblxuXG4gICAgLy8gQHBhcmFtIHtib29sZWFufSB3aGV0aGVyIHNob3VsZCBjaGVjayBpZiB0aGUgcGF0aCBpcyB1bmlnbm9yZWQsXG4gICAgLy8gICBzZXR0aW5nIGBjaGVja1VuaWdub3JlZGAgdG8gYGZhbHNlYCBjb3VsZCByZWR1Y2UgYWRkaXRpb25hbFxuICAgIC8vICAgcGF0aCBtYXRjaGluZy5cblxuICAgIC8vIEByZXR1cm5zIHtUZXN0UmVzdWx0fSB0cnVlIGlmIGEgZmlsZSBpcyBpZ25vcmVkXG4gIH0sIHtcbiAgICBrZXk6IFwiX3Rlc3RPbmVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX3Rlc3RPbmUocGF0aCwgY2hlY2tVbmlnbm9yZWQpIHtcbiAgICAgIHZhciBpZ25vcmVkID0gZmFsc2U7XG4gICAgICB2YXIgdW5pZ25vcmVkID0gZmFsc2U7XG4gICAgICB0aGlzLl9ydWxlcy5mb3JFYWNoKGZ1bmN0aW9uIChydWxlKSB7XG4gICAgICAgIHZhciBuZWdhdGl2ZSA9IHJ1bGUubmVnYXRpdmU7XG4gICAgICAgIGlmICh1bmlnbm9yZWQgPT09IG5lZ2F0aXZlICYmIGlnbm9yZWQgIT09IHVuaWdub3JlZCB8fCBuZWdhdGl2ZSAmJiAhaWdub3JlZCAmJiAhdW5pZ25vcmVkICYmICFjaGVja1VuaWdub3JlZCkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB2YXIgbWF0Y2hlZCA9IHJ1bGUucmVnZXgudGVzdChwYXRoKTtcbiAgICAgICAgaWYgKG1hdGNoZWQpIHtcbiAgICAgICAgICBpZ25vcmVkID0gIW5lZ2F0aXZlO1xuICAgICAgICAgIHVuaWdub3JlZCA9IG5lZ2F0aXZlO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGlnbm9yZWQ6IGlnbm9yZWQsXG4gICAgICAgIHVuaWdub3JlZDogdW5pZ25vcmVkXG4gICAgICB9O1xuICAgIH1cblxuICAgIC8vIEByZXR1cm5zIHtUZXN0UmVzdWx0fVxuICB9LCB7XG4gICAga2V5OiBcIl90ZXN0XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF90ZXN0KG9yaWdpbmFsUGF0aCwgY2FjaGUsIGNoZWNrVW5pZ25vcmVkLCBzbGljZXMpIHtcbiAgICAgIHZhciBwYXRoID0gb3JpZ2luYWxQYXRoXG4gICAgICAvLyBTdXBwb3J0cyBudWxsYWJsZSBwYXRoXG4gICAgICAmJiBjaGVja1BhdGguY29udmVydChvcmlnaW5hbFBhdGgpO1xuICAgICAgY2hlY2tQYXRoKHBhdGgsIG9yaWdpbmFsUGF0aCwgdGhpcy5fYWxsb3dSZWxhdGl2ZVBhdGhzID8gUkVUVVJOX0ZBTFNFIDogdGhyb3dFcnJvcik7XG4gICAgICByZXR1cm4gdGhpcy5fdChwYXRoLCBjYWNoZSwgY2hlY2tVbmlnbm9yZWQsIHNsaWNlcyk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcIl90XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF90KHBhdGgsIGNhY2hlLCBjaGVja1VuaWdub3JlZCwgc2xpY2VzKSB7XG4gICAgICBpZiAocGF0aCBpbiBjYWNoZSkge1xuICAgICAgICByZXR1cm4gY2FjaGVbcGF0aF07XG4gICAgICB9XG4gICAgICBpZiAoIXNsaWNlcykge1xuICAgICAgICAvLyBwYXRoL3RvL2EuanNcbiAgICAgICAgLy8gWydwYXRoJywgJ3RvJywgJ2EuanMnXVxuICAgICAgICBzbGljZXMgPSBwYXRoLnNwbGl0KFNMQVNIKTtcbiAgICAgIH1cbiAgICAgIHNsaWNlcy5wb3AoKTtcblxuICAgICAgLy8gSWYgdGhlIHBhdGggaGFzIG5vIHBhcmVudCBkaXJlY3RvcnksIGp1c3QgdGVzdCBpdFxuICAgICAgaWYgKCFzbGljZXMubGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiBjYWNoZVtwYXRoXSA9IHRoaXMuX3Rlc3RPbmUocGF0aCwgY2hlY2tVbmlnbm9yZWQpO1xuICAgICAgfVxuICAgICAgdmFyIHBhcmVudCA9IHRoaXMuX3Qoc2xpY2VzLmpvaW4oU0xBU0gpICsgU0xBU0gsIGNhY2hlLCBjaGVja1VuaWdub3JlZCwgc2xpY2VzKTtcblxuICAgICAgLy8gSWYgdGhlIHBhdGggY29udGFpbnMgYSBwYXJlbnQgZGlyZWN0b3J5LCBjaGVjayB0aGUgcGFyZW50IGZpcnN0XG4gICAgICByZXR1cm4gY2FjaGVbcGF0aF0gPSBwYXJlbnQuaWdub3JlZFxuICAgICAgLy8gPiBJdCBpcyBub3QgcG9zc2libGUgdG8gcmUtaW5jbHVkZSBhIGZpbGUgaWYgYSBwYXJlbnQgZGlyZWN0b3J5IG9mXG4gICAgICAvLyA+ICAgdGhhdCBmaWxlIGlzIGV4Y2x1ZGVkLlxuICAgICAgPyBwYXJlbnQgOiB0aGlzLl90ZXN0T25lKHBhdGgsIGNoZWNrVW5pZ25vcmVkKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiaWdub3Jlc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBpZ25vcmVzKHBhdGgpIHtcbiAgICAgIHJldHVybiB0aGlzLl90ZXN0KHBhdGgsIHRoaXMuX2lnbm9yZUNhY2hlLCBmYWxzZSkuaWdub3JlZDtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiY3JlYXRlRmlsdGVyXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNyZWF0ZUZpbHRlcigpIHtcbiAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICByZXR1cm4gZnVuY3Rpb24gKHBhdGgpIHtcbiAgICAgICAgcmV0dXJuICFfdGhpcy5pZ25vcmVzKHBhdGgpO1xuICAgICAgfTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZmlsdGVyXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGZpbHRlcihwYXRocykge1xuICAgICAgcmV0dXJuIG1ha2VBcnJheShwYXRocykuZmlsdGVyKHRoaXMuY3JlYXRlRmlsdGVyKCkpO1xuICAgIH1cblxuICAgIC8vIEByZXR1cm5zIHtUZXN0UmVzdWx0fVxuICB9LCB7XG4gICAga2V5OiBcInRlc3RcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gdGVzdChwYXRoKSB7XG4gICAgICByZXR1cm4gdGhpcy5fdGVzdChwYXRoLCB0aGlzLl90ZXN0Q2FjaGUsIHRydWUpO1xuICAgIH1cbiAgfV0pO1xuICByZXR1cm4gSWdub3JlO1xufSgpO1xudmFyIGZhY3RvcnkgPSBmdW5jdGlvbiBmYWN0b3J5KG9wdGlvbnMpIHtcbiAgcmV0dXJuIG5ldyBJZ25vcmUob3B0aW9ucyk7XG59O1xudmFyIGlzUGF0aFZhbGlkID0gZnVuY3Rpb24gaXNQYXRoVmFsaWQocGF0aCkge1xuICByZXR1cm4gY2hlY2tQYXRoKHBhdGggJiYgY2hlY2tQYXRoLmNvbnZlcnQocGF0aCksIHBhdGgsIFJFVFVSTl9GQUxTRSk7XG59O1xuZmFjdG9yeS5pc1BhdGhWYWxpZCA9IGlzUGF0aFZhbGlkO1xuXG4vLyBGaXhlcyB0eXBlc2NyaXB0XG5mYWN0b3J5W1wiZGVmYXVsdFwiXSA9IGZhY3Rvcnk7XG5tb2R1bGUuZXhwb3J0cyA9IGZhY3Rvcnk7XG5cbi8vIFdpbmRvd3Ncbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4vKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbmlmIChcbi8vIERldGVjdCBgcHJvY2Vzc2Agc28gdGhhdCBpdCBjYW4gcnVuIGluIGJyb3dzZXJzLlxudHlwZW9mIHByb2Nlc3MgIT09ICd1bmRlZmluZWQnICYmIChwcm9jZXNzLmVudiAmJiBwcm9jZXNzLmVudi5JR05PUkVfVEVTVF9XSU4zMiB8fCBwcm9jZXNzLnBsYXRmb3JtID09PSAnd2luMzInKSkge1xuICAvKiBlc2xpbnQgbm8tY29udHJvbC1yZWdleDogXCJvZmZcIiAqL1xuICB2YXIgbWFrZVBvc2l4ID0gZnVuY3Rpb24gbWFrZVBvc2l4KHN0cikge1xuICAgIHJldHVybiAvXlxcXFxcXFxcXFw/XFxcXC8udGVzdChzdHIpIHx8IC9bXFwwLVxceDFGXCI8PlxcfF0rLy50ZXN0KHN0cikgPyBzdHIgOiBzdHIucmVwbGFjZSgvXFxcXC9nLCAnLycpO1xuICB9O1xuICBjaGVja1BhdGguY29udmVydCA9IG1ha2VQb3NpeDtcblxuICAvLyAnQzpcXFxcZm9vJyAgICAgPC0gJ0M6XFxcXGZvbycgaGFzIGJlZW4gY29udmVydGVkIHRvICdDOi8nXG4gIC8vICdkOlxcXFxmb28nXG4gIHZhciBSRUdJWF9JU19XSU5ET1dTX1BBVEhfQUJTT0xVVEUgPSAvXlthLXpdOlxcLy9pO1xuICBjaGVja1BhdGguaXNOb3RSZWxhdGl2ZSA9IGZ1bmN0aW9uIChwYXRoKSB7XG4gICAgcmV0dXJuIFJFR0lYX0lTX1dJTkRPV1NfUEFUSF9BQlNPTFVURS50ZXN0KHBhdGgpIHx8IGlzTm90UmVsYXRpdmUocGF0aCk7XG4gIH07XG59XG4iXSwKICAibWFwcGluZ3MiOiAiOzs7Ozs7QUFBQTtBQUFBO0FBRUEsYUFBUyxRQUFRLEtBQUs7QUFBRTtBQUEyQixhQUFPLFVBQVUsY0FBYyxPQUFPLFVBQVUsWUFBWSxPQUFPLE9BQU8sV0FBVyxTQUFVQSxNQUFLO0FBQUUsZUFBTyxPQUFPQTtBQUFBLE1BQUssSUFBSSxTQUFVQSxNQUFLO0FBQUUsZUFBT0EsUUFBTyxjQUFjLE9BQU8sVUFBVUEsS0FBSSxnQkFBZ0IsVUFBVUEsU0FBUSxPQUFPLFlBQVksV0FBVyxPQUFPQTtBQUFBLE1BQUssR0FBRyxRQUFRLEdBQUc7QUFBQSxJQUFHO0FBQy9VLGFBQVMsa0JBQWtCLFFBQVEsT0FBTztBQUFFLGVBQVMsSUFBSSxHQUFHLElBQUksTUFBTSxRQUFRLEtBQUs7QUFBRSxZQUFJLGFBQWEsTUFBTSxDQUFDO0FBQUcsbUJBQVcsYUFBYSxXQUFXLGNBQWM7QUFBTyxtQkFBVyxlQUFlO0FBQU0sWUFBSSxXQUFXLFdBQVksWUFBVyxXQUFXO0FBQU0sZUFBTyxlQUFlLFFBQVEs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UTtBQUNaLGlCQUFPLFNBQVUsTUFBTTtBQUNyQixtQkFBTyxDQUFDLE1BQU0sUUFBUSxJQUFJO0FBQUEsVUFDNUI7QUFBQSxRQUNGO0FBQUEsTUFDRixHQUFHO0FBQUEsUUFDRCxLQUFLO0FBQUEsUUFDTCxPQUFPLFNBQVMsT0FBTyxPQUFPO0FBQzVCLGlCQUFPLFVBQVUsS0FBSyxFQUFFLE9BQU8sS0FBSyxhQUFhLENBQUM7QUFBQSxRQUNwRDtBQUFBO0FBQUEsTUFHRixHQUFHO0FBQUEsUUFDRCxLQUFLO0FBQUEsUUFDTCxPQUFPLFNBQVMsS0FBSyxNQUFNO0FBQ3pCLGlCQUFPLEtBQUssTUFBTSxNQUFNLEtBQUssWUFBWSxJQUFJO0FBQUEsUUFDL0M7QUFBQSxNQUNGLENBQUMsQ0FBQztBQUNGLGFBQU9BO0FBQUEsSUFDVCxFQUFFO0FBQ0YsUUFBSSxVQUFVLFNBQVNDLFNBQVEsU0FBUztBQUN0QyxhQUFPLElBQUksT0FBTyxPQUFPO0FBQUEsSUFDM0I7QUFDQSxRQUFJLGNBQWMsU0FBU0MsYUFBWSxNQUFNO0FBQzNDLGFBQU8sVUFBVSxRQUFRLFVBQVUsUUFBUSxJQUFJLEdBQUcsTUFBTSxZQUFZO0FBQUEsSUFDdEU7QUFDQSxZQUFRLGNBQWM7QUFHdEIsWUFBUSxTQUFTLElBQUk7QUFDckIsV0FBTyxVQUFVO0FBS2pCO0FBQUE7QUFBQSxNQUVBLE9BQU8sWUFBWSxnQkFBZ0IsUUFBUSxPQUFPLFFBQVEsSUFBSSxxQkFBcUIsUUFBUSxhQUFhO0FBQUEsTUFBVTtBQUU1RyxrQkFBWSxTQUFTQyxXQUFVLEtBQUs7QUFDdEMsZUFBTyxZQUFZLEtBQUssR0FBRyxLQUFLLGtCQUFrQixLQUFLLEdBQUcsSUFBSSxNQUFNLElBQUksUUFBUSxPQUFPLEdBQUc7QUFBQSxNQUM1RjtBQUNBLGdCQUFVLFVBQVU7QUFJaEIsdUNBQWlDO0FBQ3JDLGdCQUFVLGdCQUFnQixTQUFVLE1BQU07QUFDeEMsZUFBTywrQkFBK0IsS0FBSyxJQUFJLEtBQUssY0FBYyxJQUFJO0FBQUEsTUFDeEU7QUFBQSxJQUNGO0FBWE07QUFPQTtBQUFBO0FBQUE7IiwKICAibmFtZXMiOiBbIm9iaiIsICJkZWZpbmUiLCAiUkVUVVJOX0ZBTFNFIiwgInNhbml0aXplUmFuZ2UiLCAiY2xlYW5SYW5nZUJhY2tTbGFzaCIsICJtYWtlUmVnZXgiLCAiaXNTdHJpbmciLCAiY2hlY2tQYXR0ZXJuIiwgInNwbGl0UGF0dGVybiIsICJJZ25vcmVSdWxlIiwgImNyZWF0ZVJ1bGUiLCAidGhyb3dFcnJvciIsICJjaGVja1BhdGgiLCAiaXNOb3RSZWxhdGl2ZSIsICJJZ25vcmUiLCAiZmFjdG9yeSIsICJpc1BhdGhWYWxpZCIsICJtYWtlUG9zaXgiXQp9Cg==
